/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var protectedNames = [
    'data',
    'indexes',
    'groups',
    'computed',
    'actions',
    'routes'
];
var collectionFunctions = [
    'collect',
    'replaceIndex',
    'getGroup',
    'newGroup',
    'deleteGroup',
    'removeFromGroup',
    'update',
    'increment',
    'decrement',
    'delete',
    'purge',
    'watch',
    'findById',
    'put',
    'throttle',
    // deprecated
    'remove'
];
function defineConfig(config, defaults) {
    return __assign({}, defaults, config);
}
function uuid() {
    return (Math.random()
        .toString()
        .split('.')[1] + Date.now());
}
function objectLoop(object, callback, keys) {
    var objectKeys = keys ? keys : Object.keys(object);
    for (var i = 0; i < objectKeys.length; i++) {
        var key = objectKeys[i];
        var value = object[key];
        callback(key, value, objectKeys);
    }
}
function normalizeMap(map) {
    return Array.isArray(map)
        ? map.map(function (key) { return ({ key: key, val: key }); })
        : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); });
}
var arrayFunctions = [
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
];
function assert(func, funcName) {
    function warn(message) {
        if (funcName)
            console.log("Pulse / " + funcName + " / " + message);
        else
            console.warn("Pulse / " + message);
        return false;
    }
    var warnings = {
        NO_PRIMARY_KEY: function () { return warn('No primary key found!'); },
        INVALID_PARAMETER: function () { return warn('Invalid parameter supplied to function.'); },
        INDEX_NOT_FOUND: function () { return warn('Index was not found on collection.'); },
        INTERNAL_DATA_NOT_FOUND: function () { return warn('Data was not found on collection.'); },
        PROPERTY_NOT_A_NUMBER: function () { return warn('Property is not a number!'); }
    };
    return func(warnings)();
}
function isWatchableObject(value) {
    function isHTMLElement(obj) {
        try {
            return obj instanceof HTMLElement;
        }
        catch (e) {
            return (typeof obj === 'object' &&
                obj.nodeType === 1 &&
                typeof obj.style === 'object' &&
                typeof obj.ownerDocument === 'object');
        }
    }
    var type = typeof value;
    return (value != null &&
        type == 'object' &&
        !isHTMLElement(value) &&
        !Array.isArray(value));
}
function validateNumber(mutable, amount) {
    if (typeof amount !== 'number' || typeof mutable !== 'number') {
        return false;
    }
    return true;
}
//# sourceMappingURL=helpers.js.map

var JobType;
(function (JobType) {
    JobType["PUBLIC_DATA_MUTATION"] = "PUBLIC_DATA_MUTATION";
    JobType["INTERNAL_DATA_MUTATION"] = "INTERNAL_DATA_MUTATION";
    JobType["INDEX_UPDATE"] = "INDEX_UPDATE";
    JobType["COMPUTED_REGEN"] = "COMPUTED_REGEN";
    JobType["GROUP_UPDATE"] = "GROUP_UPDATE";
    JobType["DEEP_PUBLIC_DATA_MUTATION"] = "DEEP_PUBLIC_DATA_MUTATION";
    JobType["BULK_INTERNAL_DATA_MUTATION"] = "BULK_INTERNAL_DATA_MUTATION";
    JobType["DELETE_INTERNAL_DATA"] = "DELETE_INTERNAL_DATA";
})(JobType || (JobType = {}));
//# sourceMappingURL=interfaces.js.map

var Runtime = /** @class */ (function () {
    function Runtime(collections, global) {
        this.collections = collections;
        this.global = global;
        this.running = false;
        this.updatingSubscribers = false;
        this.ingestQueue = [];
        this.completedJobs = [];
        this.archivedJobs = [];
        global.ingest = this.ingest.bind(this);
        global.searchIndexes = this.searchIndexes.bind(this);
        this.config = global.config;
    }
    Runtime.prototype.ingest = function (job) {
        // console.log(job);
        // if (this.ingestQueue.length > 0) {
        //   this.ingestQueue = this.ingestQueue.computed(
        //     item =>
        //       item.type !== job.type &&
        //       item.collection !== job.collection &&
        //       item.property !== job.property
        //   );
        // }
        this.ingestQueue.push(job);
        if (!this.running) {
            this.findNextJob();
        }
    };
    Runtime.prototype.findNextJob = function () {
        this.running = true;
        var next = this.ingestQueue.shift();
        // non public data properties such as groups, computed and indexes will not have their dep, so get it.
        if (!next.dep)
            next.dep = this.collections[next.collection].public.getDep(next.property);
        // execute the next task in the queue
        this.performJob(next);
    };
    Runtime.prototype.performJob = function (job) {
        var _this = this;
        if (job.value === 2550)
            if (job.type === JobType.INDEX_UPDATE &&
                job.dep.name === 'currentViewingSubscribed')
                // if (job.type !== JobType.INTERNAL_DATA_MUTATION)
                //   console.log(job.type, job.collection, job.property.name || job.property);
                debugger;
        switch (job.type) {
            case JobType.PUBLIC_DATA_MUTATION:
                this.performPublicDataUpdate(job);
                this.collections[job.collection].runWatchers(job.property);
                break;
            case JobType.INTERNAL_DATA_MUTATION:
                this.performInternalDataUpdate(job);
                break;
            case JobType.BULK_INTERNAL_DATA_MUTATION:
                // this.performInternalDataUpdate(collection, property, value);
                break;
            case JobType.INDEX_UPDATE:
                this.performIndexUpdate(job);
                break;
            case JobType.COMPUTED_REGEN:
                this.performComputedOutput(job);
                this.collections[job.collection].runWatchers(job.property.name);
                break;
            case JobType.GROUP_UPDATE:
                this.performGroupRebuild(job);
                this.collections[job.collection].runWatchers(job.property);
                break;
            case JobType.DELETE_INTERNAL_DATA:
                this.performInternalDataDeletion(job);
                break;
            default:
                break;
        }
        // unpack dependent computed
        if (job.dep && job.dep.dependents.size > 0) {
            // log(`Queueing ${dep.dependents.size} dependents`);
            job.dep.dependents.forEach(function (computed) {
                // get dep from public computed output
                _this.ingest({
                    type: JobType.COMPUTED_REGEN,
                    collection: computed.collection,
                    property: computed,
                    dep: _this.collections[computed.collection].public.getDep(computed.name)
                });
            });
        }
        this.finished();
    };
    Runtime.prototype.finished = function () {
        var _this = this;
        this.running = false;
        if (this.completedJobs.length > 5000)
            return;
        // If there's already more stuff in the queue, loop.
        if (this.ingestQueue.length > 0) {
            this.findNextJob();
            return;
        }
        // Wait until callstack is empty to check if we should finalise this body of work
        setTimeout(function () {
            if (_this.ingestQueue.length === 0) {
                if (!_this.updatingSubscribers)
                    _this.compileComponentUpdates();
                _this.cleanup();
            }
            else {
                // loop more!
                _this.findNextJob();
            }
        });
    };
    // Jobs runtime can perform
    Runtime.prototype.performPublicDataUpdate = function (job) {
        this.writeToPublicObject(job.collection, 'data', job.property, job.value);
        this.completedJob(job);
    };
    Runtime.prototype.performInternalDataUpdate = function (job) {
        job.previousValue = this.overwriteInternalData(job.collection, job.property, job.value);
        // only look for indexes if we're not collecting data
        if (this.global.collecting) ;
        // find and ingest direct depenecies on data
        this.global.relations.internalDataModified(job.collection, job.property);
        this.findIndexesToUpdate(job.collection, job.property);
        this.completedJob(job);
    };
    Runtime.prototype.performInternalDataDeletion = function (job) {
        var c = this.collections[job.collection];
        // preserve previous value
        job.previousValue = __assign({}, c.internalData[job.property]);
        // delete data
        delete c.internalData[job.property];
        // find indexes affected by this data deletion
        var indexesToUpdate = this.searchIndexes(job.collection, job.property);
        // for each found index, perform index update
        for (var i = 0; i < indexesToUpdate.length; i++) {
            var indexName = indexesToUpdate[i];
            var newIndex = c.indexes.object[indexName].slice().computed(function (id) { return id !== job.property; });
            this.ingest({
                type: JobType.INDEX_UPDATE,
                collection: c.name,
                property: indexName,
                value: newIndex,
                dep: this.collections[job.collection].public.getDep(job.property)
            });
        }
        this.completedJob(job);
    };
    Runtime.prototype.performIndexUpdate = function (job) {
        // preserve old index
        job.previousValue = this.collections[job.collection].indexes[job.property];
        // Update Index
        this.collections[job.collection].indexes.privateWrite(job.property, job.value);
        this.completedJob(job);
        // Group must also be updated
        this.ingest({
            type: JobType.GROUP_UPDATE,
            collection: job.collection,
            property: job.property,
            dep: this.collections[job.collection].public.getDep(job.property)
        });
    };
    Runtime.prototype.performGroupRebuild = function (job) {
        job.value = this.collections[job.collection].buildGroupFromIndex(job.property);
        this.ingestForeignRelatedGroups(job.collection, job.property);
        this.writeToPublicObject(job.collection, 'group', job.property, job.value);
        this.completedJob(job);
    };
    Runtime.prototype.performComputedOutput = function (job) {
        var computed = typeof job.property === 'string'
            ? this.collections[job.collection].computed[job.property]
            : job.property;
        job.value = computed.run();
        // Commit Update
        this.writeToPublicObject(job.collection, 'computed', computed.name, job.value);
        this.completedJob(job);
    };
    // Handlers for committing updates
    Runtime.prototype.writeToPublicObject = function (collection, type, key, value) {
        if (type === 'indexes') {
            if (!this.collections[collection][type].object.hasOwnProperty(key))
                return;
            this.collections[collection][type].privateWrite(key, value);
        }
        else {
            if (!this.collections[collection].public.object.hasOwnProperty(key))
                return;
            this.collections[collection].public.privateWrite(key, value);
        }
    };
    Runtime.prototype.completedJob = function (job) {
        job.fromAction = this.global.runningAction;
        if (this.global.initComplete)
            this.completedJobs.push(job);
        this.persistData(job);
    };
    Runtime.prototype.compileComponentUpdates = function () {
        if (!this.global.initComplete)
            return;
        this.updatingSubscribers = true;
        console.log('ALL JOBS COMPLETE', this.completedJobs);
        console.log('Updating components...');
        var componentsToUpdate = {};
        var subscribe = function (value, subscribers) {
            for (var i = 0; i < subscribers.length; i++) {
                var uuid = subscribers[i].componentUUID;
                var key = subscribers[i].key;
                if (!componentsToUpdate[uuid]) {
                    componentsToUpdate[uuid] = {};
                    componentsToUpdate[uuid][key] = value;
                }
                else {
                    componentsToUpdate[uuid][key] = value;
                }
            }
        };
        for (var i = 0; i < this.completedJobs.length; i++) {
            var job = this.completedJobs[i];
            if (job.dep)
                subscribe(job.value, job.dep.subscribers);
        }
        console.log(componentsToUpdate);
        this.updateSubscribers(componentsToUpdate);
        this.completedJobs = [];
    };
    Runtime.prototype.updateSubscribers = function (componentsToUpdate) {
        var componentKeys = Object.keys(componentsToUpdate);
        var _loop_1 = function (i) {
            var componentID = componentKeys[i];
            var componentInstance = this_1.global.subs.componentStore[componentID];
            if (!componentInstance || !componentInstance.instance)
                return { value: void 0 };
            var propertiesToUpdate = componentsToUpdate[componentID];
            var dataKeys = Object.keys(propertiesToUpdate);
            dataKeys.forEach(function (property) {
                var value = propertiesToUpdate[property];
                componentInstance.instance.$set(componentInstance.instance, property, value);
            });
        };
        var this_1 = this;
        for (var i = 0; i < componentKeys.length; i++) {
            var state_1 = _loop_1(i);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    };
    Runtime.prototype.persistData = function (job) {
        if (job.type === JobType.INTERNAL_DATA_MUTATION)
            return;
        if (this.collections[job.collection].persist.includes(job.property)) {
            this.global.storage.set(job.collection, job.property, job.value);
        }
    };
    Runtime.prototype.cleanup = function () {
        var _this = this;
        setTimeout(function () {
            _this.updatingSubscribers = false;
        });
    };
    Runtime.prototype.findIndexesToUpdate = function (collection, keys) {
        var foundIndexes = new Set();
        var c = this.collections[collection];
        if (!Array.isArray(keys))
            keys = [keys];
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var searchIndexes = this.searchIndexes(collection, key);
            searchIndexes.forEach(function (index) { return foundIndexes.add(index); });
        }
        // foundIndexes.forEach((index: string) => {
        //   this.ingest({
        //     type: JobType.INDEX_UPDATE,
        //     collection: c.name,
        //     property: index,
        //     dep: this.collections[c.name].indexes.getDep(index)
        //   });
        // });
    };
    // when groups are rebuilt, find other groups that are dependent on this group
    // (defined using "hasMany" in the model) and ingest those groups into the queue.
    Runtime.prototype.ingestForeignRelatedGroups = function (collection, groupName) {
        var _this = this;
        var relations = this.collections[collection].foreignGroupRelations;
        objectLoop(relations, function (relationKey, relation) {
            if (relationKey === groupName)
                _this.ingest({
                    type: JobType.GROUP_UPDATE,
                    collection: relation.collection,
                    property: relation.groupToRegen,
                    dep: _this.collections[relation.collection].public.getDep(relation.groupToRegen)
                });
        });
    };
    Runtime.prototype.searchIndexes = function (collection, primaryKey) {
        var c = this.collections[collection];
        var keys = Object.keys(c.indexes.object);
        var foundIndexes = [];
        for (var i = 0; i < keys.length; i++) {
            var indexName = keys[i];
            if (c.indexes.object[indexName].includes(primaryKey))
                foundIndexes.push(indexName);
        }
        return foundIndexes;
    };
    Runtime.prototype.overwriteInternalData = function (collection, primaryKey, newData) {
        var currentData = Object.assign({}, this.collections[collection].internalData[primaryKey]);
        if (currentData[primaryKey]) {
            // data already exists, merge objects and return previous object
            var keys = Object.keys(newData);
            for (var i = 0; i < keys.length; i++) {
                var property = keys[i];
                this.collections[collection].internalData[primaryKey][property] =
                    newData[property];
            }
            return currentData;
        }
        else {
            // data does not exist, write and return false
            this.collections[collection].internalData[primaryKey] = newData;
            return false;
        }
    };
    return Runtime;
}());
//# sourceMappingURL=runtime.js.map

var Dep = /** @class */ (function () {
    function Dep(global, name, rootProperty, propertyOnObject) {
        this.global = global;
        this.name = name;
        this.rootProperty = rootProperty;
        this.propertyOnObject = propertyOnObject;
        this.dependents = new Set();
        this.subscribers = [];
    }
    Dep.prototype.register = function () {
        var subs = this.global.subs;
        if (this.global.runningComputed) {
            this.dependents.add(this.global.runningComputed);
        }
        if (subs.subscribingComponent) {
            this.subscribeComponent();
        }
        if (subs.unsubscribingComponent) ;
    };
    Dep.prototype.subscribeComponent = function () {
        var subs = this.global.subs;
        if (this.rootProperty && subs.skimmingDeepReactive) {
            subs.prepareNext(this);
            return;
        }
        if (this.rootProperty) {
            subs.foundDeepReactive();
            subs.prepareNext(this);
            return;
        }
        if (!this.rootProperty && subs.skimmingDeepReactive) {
            subs.exitDeepReactive();
        }
        this.subscribe();
        subs.prepareNext(this);
    };
    Dep.prototype.subscribe = function () {
        var subs = this.global.subs;
        var keys = subs.subscribingComponent.keys;
        var key = keys[subs.subscribingComponentKey];
        var component = {
            componentUUID: subs.subscribingComponent.componentUUID,
            key: key
        };
        this.subscribers.push(component);
    };
    return Dep;
}());
//# sourceMappingURL=dep.js.map

var Reactive = /** @class */ (function () {
    function Reactive(object, global, collection, mutable, type) {
        if (object === void 0) { object = {}; }
        this.global = global;
        this.collection = collection;
        this.mutable = mutable;
        this.type = type;
        this.allowPrivateWrite = false;
        this.touching = false;
        this.dispatch = this.global.dispatch;
        this.properties = Object.keys(object);
        this.object = this.reactiveObject(object);
    }
    Reactive.prototype.reactiveObject = function (object, rootProperty) {
        var self = this;
        var objectKeys = Object.keys(object);
        var _loop_1 = function (i) {
            var key = objectKeys[i];
            var rootProperty_1 = object.rootProperty;
            var currentProperty = key;
            var value = object[key];
            // If property is an array, make it reactive
            if (Array.isArray(value)) ;
            else if (isWatchableObject(value) && !protectedNames.includes(key)) {
                // rootProperty should be the current key if first deep object
                value = this_1.deepReactiveObject(value, rootProperty_1 || key, currentProperty);
            }
            // Create an instance of the dependency tracker
            var dep = new Dep(this_1.global, key, rootProperty_1, currentProperty);
            Object.defineProperty(object, key, {
                get: function pulseGetter() {
                    if (self.touching) {
                        self.touched = dep;
                        return;
                    }
                    dep.register();
                    return value;
                },
                set: function pulseSetter(newValue) {
                    // rootProperty indicates if the object is "deep".
                    if (rootProperty_1 && self.mutable.includes(rootProperty_1)) {
                        // mutate locally
                        value = newValue;
                        // dispatch mutation for rootProperty
                        self.dispatch('mutation', {
                            collection: self.collection,
                            key: rootProperty_1,
                            value: self.object[rootProperty_1],
                            dep: dep
                        });
                    }
                    else {
                        // if backdoor open or is protected name, allow direct mutation
                        if (self.allowPrivateWrite || protectedNames.includes(key))
                            return (value = newValue);
                        // if property is mutable dispatch update
                        if (self.mutable.includes(key)) {
                            self.dispatch('mutation', {
                                collection: self.collection,
                                key: key,
                                value: newValue,
                                dep: dep
                            });
                            // we did not apply the mutation since runtime will privatly
                            // write the result since we dispatched above
                        }
                    }
                }
            });
        };
        var this_1 = this;
        // Loop over all properties of the to-be reactive object
        for (var i = 0; i < objectKeys.length; i++) {
            _loop_1(i);
        }
        return object;
    };
    Reactive.prototype.deepReactiveObject = function (value, rootProperty, propertyOnObject) {
        var objectWithCustomPrototype = Object.create({
            rootProperty: rootProperty,
            propertyOnObject: propertyOnObject
        });
        // repopulate custom object with incoming values
        var keys = Object.keys(value);
        for (var i = 0; i < keys.length; i++) {
            var property = keys[i];
            objectWithCustomPrototype[property] = value[property];
        }
        this.allowPrivateWrite = true;
        var obj = this.reactiveObject(objectWithCustomPrototype, rootProperty);
        this.allowPrivateWrite = false;
        return obj;
    };
    Reactive.prototype.reactiveArray = function (array, key) {
        var self = this;
        var reactiveArray = array.slice();
        var _loop_2 = function (i) {
            var func = arrayFunctions[i];
            var original = Array.prototype[func];
            Object.defineProperty(reactiveArray, func, {
                value: function () {
                    var result = original.apply(this, arguments);
                    if (self.global.initComplete)
                        self.dispatch('mutation', {
                            collection: self.collection,
                            key: key,
                            value: result
                        });
                    return result;
                }
            });
        };
        for (var i = 0; i < arrayFunctions.length; i++) {
            _loop_2(i);
        }
        return reactiveArray;
    };
    Reactive.prototype.privateWrite = function (property, value) {
        if (value === undefined)
            debugger;
        this.allowPrivateWrite = true;
        this.object[property] = value;
        this.allowPrivateWrite = false;
    };
    Reactive.prototype.privateGetValue = function (property) {
        return this.object[property];
    };
    Reactive.prototype.exists = function (property) {
        return !!this.object.hasOwnProperty(property);
    };
    Reactive.prototype.getDep = function (property) {
        this.touching = true;
        var _ = this.object[property]; // eslint-disable-line no-unused-var
        var dep = this.touched;
        this.touching = false;
        return dep;
    };
    return Reactive;
}());
// look for computed output access to determine dependencies
// remove computed categories from public object on default config
//# sourceMappingURL=reactive.js.map

var Action = /** @class */ (function () {
    function Action(collection, global, action, actionName) {
        this.collection = collection;
        this.global = global;
        this.action = action;
        this.actionName = actionName;
        this.executing = false;
        this.uuid = uuid();
        this.prepare(action, global, this.global.contextRef.undo);
    }
    Action.prototype.prepare = function (action, global, undo) {
        var _this = this;
        this.exec = function () {
            var _this_1 = this;
            var context = global.getContext(_this.collection);
            context.undo = function (error) {
                return undo(_this_1.actionName, _this_1.uuid, error);
            };
            global.runningAction = _this;
            _this.executing = true;
            var result = action.apply(null, [context].concat(Array.prototype.slice.call(arguments)));
            _this.executing = false;
            global.runningAction = false;
            return result;
        };
    };
    return Action;
}());
//# sourceMappingURL=action.js.map

var Computed = /** @class */ (function () {
    function Computed(global, collection, name, computedFunction) {
        this.global = global;
        this.collection = collection;
        this.name = name;
        this.computedFunction = computedFunction;
        this.relatedToGroup = [];
        this.relatedToInternalData = [];
    }
    Computed.prototype.run = function () {
        // cleanup before running
        if (this.global.relations)
            this.global.relations.computedCleanup(this);
        this.global.runningComputed = this;
        var output = this.computedFunction(this.global.getContext(this.collection));
        if (output === undefined || output === null)
            output = false;
        this.global.runningComputed = false;
        return output;
    };
    Computed.prototype.addRelationToGroup = function (collectionName, groupName) { };
    Computed.prototype.addRelationToInternalData = function (collectionName, primaryKey) {
        // const stringified = JSON.stringify({
        //   collection: collectionName,
        //   primaryKey
        // });
        // if (!this.relatedToInternalData.includes(stringified))
        //   this.relatedToInternalData.push(stringified);
    };
    return Computed;
}());
//# sourceMappingURL=computed.js.map

var Collection = /** @class */ (function () {
    function Collection(name, global, root) {
        this.name = name;
        this.global = global;
        this.config = {};
        this.keys = {};
        this.methods = {};
        this.actions = {};
        this.computed = {};
        this.watchers = {};
        this.externalWatchers = {};
        this.persist = [];
        this.collectionSize = 0;
        this.primaryKey = false;
        this.internalData = {};
        this.dataRelations = {};
        this.groupRelations = {};
        this.foreignGroupRelations = {};
        this.config = root.config;
        this.dispatch = this.global.dispatch;
        // legacy support
        root.computed = __assign({}, root.computed, root.filters);
        root = this.prepareNamespace(root);
        this.initReactive(root.data, root.groups);
        this.initRoutes(root.routes);
        this.initActions(root.actions);
        this.initWatchers(root.watch);
        this.initComputed(root.computed);
        this.initModel(root.model);
        this.initPersist(root.persist);
    }
    Collection.prototype.prepareNamespace = function (root) {
        var _this = this;
        // map collection methods
        collectionFunctions.map(function (func) { return (_this.methods[func] = _this[func].bind(_this)); });
        // for each type set default and register keys
        ['data', 'actions', 'computed', 'indexes', 'routes', 'watch'].forEach(function (type) {
            if (type !== 'indexes' && !root[type])
                root[type] = {};
            _this.keys[type] =
                type === 'indexes' ? root['groups'] || [] : Object.keys(root[type]);
        });
        // assign namespace, this is used by initReactive
        this.namespace = Object.assign(Object.create(__assign({}, this.methods)), __assign({ routes: {}, indexes: {}, actions: root.actions }, root.computed, root.data, this.normalizeGroups(root.groups)));
        return root;
    };
    // groups are defined by the user as an array of strings, this converts them into object/keys
    Collection.prototype.normalizeGroups = function (groupsAsArray) {
        if (groupsAsArray === void 0) { groupsAsArray = []; }
        var groups = {};
        for (var i = 0; i < groupsAsArray.length; i++) {
            var groupName = groupsAsArray[i];
            groups[groupName] = [];
        }
        return groups;
    };
    Collection.prototype.runWatchers = function (property) {
        var watcher = this.watchers[property];
        if (watcher)
            watcher();
        var externalWatchers = this.externalWatchers[property];
        if (externalWatchers)
            externalWatchers.forEach(function (func) {
                return typeof func === 'function' ? func() : false;
            });
    };
    Collection.prototype.initReactive = function (data, groups) {
        if (groups === void 0) { groups = []; }
        groups = this.normalizeGroups(groups);
        // Make indexes reactive
        this.indexes = new Reactive(groups, // object
        this.global, // global
        this.name, // collection
        this.keys.indexes, // mutable
        'indexes' // type
        );
        this.namespace.indexes = this.indexes.object;
        // Make entire public object Reactive
        this.public = new Reactive(this.namespace, this.global, this.name, this.keys.data.concat(this.keys.indexes), 'root');
    };
    Collection.prototype.initPersist = function (persist) {
        if (!Array.isArray(persist))
            return;
        for (var i = 0; i < persist.length; i++) {
            var dataName = persist[i];
            // TODO: validate
            this.persist.push(dataName);
            var data = this.global.storage.get(this.name, dataName);
            if (data === undefined || data === null)
                continue;
            this.public.privateWrite(dataName, data);
        }
    };
    Collection.prototype.initActions = function (actions) {
        if (actions === void 0) { actions = {}; }
        var actionKeys = Object.keys(actions);
        for (var i = 0; i < actionKeys.length; i++) {
            var action = actions[actionKeys[i]];
            this.actions[actionKeys[i]] = new Action(this.name, this.global, action, actionKeys[i]);
            this.public.privateWrite(actionKeys[i], this.actions[actionKeys[i]].exec);
        }
    };
    Collection.prototype.initWatchers = function (watchers) {
        var _this = this;
        if (watchers === void 0) { watchers = {}; }
        var watcherKeys = Object.keys(watchers);
        var _loop_1 = function (i) {
            var watcher = watchers[watcherKeys[i]];
            this_1.watchers[watcherKeys[i]] = function () {
                _this.global.runningWatcher = {
                    collection: _this.name,
                    property: watcherKeys[i]
                };
                var watcherOutput = watcher(_this.global.getContext(_this.name));
                _this.global.runningWatcher = false;
                return watcherOutput;
            };
        };
        var this_1 = this;
        for (var i = 0; i < watcherKeys.length; i++) {
            _loop_1(i);
        }
        this.watchers._keys = watcherKeys;
    };
    Collection.prototype.initComputed = function (computed) {
        var _this = this;
        objectLoop(computed, function (computedName, computedFunction) {
            _this.computed[computedName] = new Computed(_this.global, _this.name, computedName, computedFunction);
            _this.public.object[computedName] = [];
        }, this.keys.computed);
    };
    Collection.prototype.initRoutes = function (routes) {
        var _this = this;
        var self = this;
        var routeWrapped = function (routeName) {
            return function () {
                var requestObject = Object.assign({}, self.global.request);
                requestObject.context = self.global.getContext();
                return routes[routeName].apply(null, [requestObject].concat(Array.prototype.slice.call(arguments)));
            };
        };
        objectLoop(routes, function (routeName) {
            return (_this.public.object.routes[routeName] = routeWrapped(routeName));
        });
    };
    Collection.prototype.initModel = function (model) {
        var _this = this;
        if (model === void 0) { model = {}; }
        Object.keys(model).forEach(function (property) {
            Object.keys(model[property]).forEach(function (config) {
                if (config === 'primaryKey') {
                    _this.primaryKey = property;
                }
                else if (config === 'type') ;
                else if (config === 'parent' || config === 'hasOne') {
                    _this.createDataRelation(property, model[property].parent || model[property].hasOne, model[property].assignTo);
                }
                else if (config === 'has' || config === 'hasMany') {
                    _this.createGroupRelation(property, model[property].has || model[property].hasMany, model[property].assignTo);
                }
            });
        });
    };
    Collection.prototype.createDataRelation = function (primaryKeyName, fromCollectionName, assignTo) {
        this.dataRelations[primaryKeyName] = {};
        this.dataRelations[primaryKeyName].fromCollectionName = fromCollectionName;
        if (assignTo)
            this.dataRelations[primaryKeyName].assignTo = assignTo;
    };
    Collection.prototype.createGroupRelation = function (primaryKeyName, fromCollectionName, assignTo) {
        this.groupRelations[primaryKeyName] = {};
        this.groupRelations[primaryKeyName].fromCollectionName = fromCollectionName;
        if (assignTo)
            this.groupRelations[primaryKeyName].assignTo = assignTo;
    };
    Collection.prototype.buildGroupFromIndex = function (groupName) {
        // console.log(collection, key)
        var constructedArray = [];
        var index = this.indexes.object[groupName];
        for (var i = 0; i < index.length; i++) {
            var id = index[i];
            var data = Object.assign({}, this.internalData[id]);
            if (!data)
                continue;
            data = this.injectDataByRelation(data);
            data = this.injectGroupByRelation(data, groupName);
            constructedArray.push(data);
        }
        return constructedArray;
    };
    Collection.prototype.injectDataByRelation = function (data) {
        // if (data.hasOwnProperty('liveStreamType')) debugger;
        var relations = Object.keys(this.dataRelations);
        if (relations.length > 0)
            for (var i = 0; i < relations.length; i++) {
                var relationKey = relations[i]; // the key on the data to look at
                var rel = this.dataRelations[relationKey]; // an object with fromCollectionName & assignTo
                var assignTo = rel.hasOwnProperty('assignTo')
                    ? rel.assignTo
                    : rel.fromCollectionName;
                if (data.hasOwnProperty(relationKey)) {
                    var foreignData = this.global.getInternalData(rel.fromCollectionName, data[relationKey]);
                    data[assignTo] = foreignData;
                }
            }
        return data;
    };
    Collection.prototype.injectGroupByRelation = function (data, groupName) {
        var groupRealtions = Object.keys(this.groupRelations);
        if (groupRealtions.length > 0)
            for (var i = 0; i < groupRealtions.length; i++) {
                var relationKey = groupRealtions[i];
                var rel = this.groupRelations[relationKey];
                var assignTo = rel.hasOwnProperty('assignTo') ? rel.assignTo : false;
                if (data.hasOwnProperty(relationKey)) {
                    var foreignData = this.global.contextRef[rel.fromCollectionName][data[relationKey]];
                    if (foreignData) {
                        if (assignTo)
                            data[assignTo] = foreignData;
                        else
                            data[rel.fromCollectionName] = foreignData;
                    }
                    // register this relation on the foreign collection for reactive updates
                    this.global.createForeignGroupRelation(rel.fromCollectionName, data[relationKey], this.name, groupName);
                }
            }
        return data;
    };
    Collection.prototype.createGroups = function (group) {
        if (group === undefined)
            group = [];
        else if (!Array.isArray(group))
            group = [group];
        for (var i = 0; i < group.length; i++) {
            var groupName = group[i];
            if (!this.indexes.object[groupName]) {
                this.indexes.object[groupName] = [];
            }
        }
        return group;
    };
    // METHODS
    Collection.prototype.collect = function (data, group, config) {
        var _this = this;
        console.log('collecting', data);
        config = defineConfig(config, {
            append: true
        });
        this.global.collecting = true;
        // normalise data
        if (!Array.isArray(data))
            data = [data];
        // if groups don't already exist, create them dynamically
        var groups = this.createGroups(group);
        // groups now contains just the groups directly modified by this collect
        // preserve index previous values
        var previousIndexValues = this.getPreviousIndexValues(groups);
        var indexesToRegenOnceComplete = new Set();
        // process data items
        for (var i = 0; i < data.length; i++) {
            var dataItem = data[i];
            // process data item returns "success" as a boolean and affectedIndexes as an array
            var processDataItem = this.processDataItem(dataItem, groups, config);
            if (processDataItem.success)
                this.collectionSize++;
            // ensure indexes modified by this data item are waiting to be ingested for regen
            processDataItem.affectedIndexes.forEach(function (index) {
                return indexesToRegenOnceComplete.add(index);
            });
        }
        console.log(group, indexesToRegenOnceComplete);
        indexesToRegenOnceComplete.forEach(function (index) {
            _this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: _this.name,
                property: index,
                value: _this.indexes.object[index],
                previousValue: previousIndexValues[index]
            });
        });
        this.global.collecting = false;
    };
    Collection.prototype.processDataItem = function (dataItem, groups, config) {
        if (groups === void 0) { groups = []; }
        if (!this.primaryKey)
            this.findPrimaryKey(dataItem);
        var key = dataItem[this.primaryKey];
        // find affected indexes
        var affectedIndexes = groups.slice();
        this.global
            .searchIndexes(this.name, key)
            .map(function (index) { return !affectedIndexes.includes(index) && affectedIndexes.push(index); });
        // validate against model
        // ingest the data
        this.global.ingest({
            type: JobType.INTERNAL_DATA_MUTATION,
            collection: this.name,
            property: key,
            value: dataItem
        });
        // add the data to group indexes
        for (var i = 0; i < groups.length; i++) {
            var groupName = groups[i];
            var index = this.indexes.object[groupName].slice();
            if (config.append)
                index.push(key);
            else
                index.unshift(key);
            this.indexes.privateWrite(groupName, index);
        }
        return { success: true, affectedIndexes: affectedIndexes };
    };
    Collection.prototype.getPreviousIndexValues = function (groups) {
        var returnData = {};
        for (var i = 0; i < groups; i++) {
            var groupName = groups[i];
            returnData[groupName] = this.indexes.object[groupName];
        }
        return returnData;
    };
    Collection.prototype.findPrimaryKey = function (dataItem) {
        if (dataItem.hasOwnProperty('id'))
            this.primaryKey = 'id';
        else if (dataItem.hasOwnProperty('_id'))
            this.primaryKey = '_id';
        else if (dataItem.hasOwnProperty('key'))
            this.primaryKey = 'key';
        if (this.primaryKey)
            return true;
        else
            return assert(function (warn) { return warn.NO_PRIMARY_KEY; });
    };
    Collection.prototype.replaceIndex = function (indexName, newIndex) {
        if (!Array.isArray(newIndex) || typeof indexName !== 'string')
            return assert(function (warn) { return warn.INVALID_PARAMETER; }, 'replaceIndex');
        this.global.ingest({
            type: JobType.INDEX_UPDATE,
            collection: this.name,
            property: indexName,
            value: newIndex
        });
    };
    Collection.prototype.findById = function (id) {
        if (!this.internalData.hasOwnProperty(id))
            return assert(function (warn) { return warn.INTERNAL_DATA_NOT_FOUND; }, 'findById');
        if (this.global.runningComputed) {
            var computed = this.global.runningComputed;
            this.global.relations.createInternalDataRelation(this.name, id, computed);
        }
        return this.internalData[id];
    };
    // action functions
    Collection.prototype.undo = function () { };
    Collection.prototype.throttle = function () { };
    // group functions
    Collection.prototype.move = function (ids, sourceIndexName, destIndexName, method) {
        if (method === void 0) { method = 'push'; }
        // validation
        if (!this.indexes.exists(sourceIndexName))
            return assert(function (warn) { return warn.INDEX_NOT_FOUND; }, 'move');
        if (destIndexName && !this.indexes.exists(destIndexName))
            return assert(function (warn) { return warn.INDEX_NOT_FOUND; }, 'move');
        if (!Array.isArray(ids))
            ids = [ids];
        var sourceIndex = this.indexes.privateGetValue(sourceIndexName);
        var _loop_2 = function (i) {
            sourceIndex.map(function (id) { return id !== ids[i]; });
        };
        for (var i = 0; i < ids.length; i++) {
            _loop_2(i);
        }
        this.global.ingest({
            type: JobType.INDEX_UPDATE,
            collection: this.name,
            property: sourceIndexName,
            value: sourceIndex
        });
        if (destIndexName) {
            var destIndex = this.indexes.privateGetValue(destIndexName);
            for (var i = 0; i < ids.length; i++)
                destIndex[method](ids[i]);
            this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: this.name,
                property: destIndexName,
                value: destIndex
            });
        }
    };
    Collection.prototype.put = function (ids, destIndexName, method) {
        if (method === void 0) { method = 'push'; }
        // validation
        if (!this.indexes.exists(destIndexName))
            return assert(function (warn) { return warn.INDEX_NOT_FOUND; }, 'put');
        if (!Array.isArray(ids))
            ids = [ids];
        var destIndex = this.indexes.privateGetValue(destIndexName);
        for (var i = 0; i < ids.length; i++)
            destIndex[method](ids[i]);
        this.global.ingest({
            type: JobType.INDEX_UPDATE,
            collection: this.name,
            property: destIndexName,
            value: destIndex
        });
    };
    Collection.prototype.getGroup = function (property) {
        if (!this.indexes.exists(property))
            return assert(function (warn) { return warn.INDEX_NOT_FOUND; }, 'group') || [];
        if (this.global.runningComputed) {
            var computed = this.global.runningComputed;
            computed.addRelationToGroup(this.name, property);
        }
        return this.buildGroupFromIndex(property) || [];
    };
    Collection.prototype.newGroup = function (groupName, indexValue) {
        if (this.indexes.object.hasOwnProperty(groupName))
            return assert(function (warn) { return warn.GROUP_ALREADY_EXISTS; }, 'newGroup');
        this.global.ingest({
            type: JobType.INDEX_UPDATE,
            collection: this.name,
            property: groupName,
            value: indexValue
        });
    };
    Collection.prototype.deleteGroup = function (groupName) {
        this.global.ingest({
            type: JobType.INDEX_UPDATE,
            collection: this.name,
            property: groupName,
            value: []
        });
    };
    Collection.prototype.removeFromGroup = function (groupName, itemsToRemove) {
        if (!this.indexes.exists(groupName))
            return assert(function (warn) { return warn.INDEX_NOT_FOUND; }, 'group');
        if (!Array.isArray(itemsToRemove))
            itemsToRemove = [itemsToRemove];
        var index = this.indexes.privateGetValue(groupName);
        var newIndex = index.computed(function (id) { return !itemsToRemove.includes(id); });
        this.global.ingest({
            type: JobType.INDEX_UPDATE,
            collection: this.name,
            property: groupName,
            value: newIndex
        });
    };
    // internal data functions
    Collection.prototype.update = function (primaryKey, newObject) {
        if (!this.internalData.hasOwnProperty(primaryKey))
            return assert(function (warn) { return warn.INTERNAL_DATA_NOT_FOUND; }, 'update');
        var newObjectKeys = Object.keys(newObject);
        var currentData = Object.assign({}, this.internalData[primaryKey]);
        for (var i = 0; i < newObjectKeys.length; i++) {
            var key = newObjectKeys[i];
            currentData[key] = newObject[key];
        }
        this.global.ingest({
            type: JobType.INTERNAL_DATA_MUTATION,
            collection: this.name,
            property: primaryKey,
            value: currentData
        });
    };
    Collection.prototype.increment = function (primaryKey, property, amount, decrement) {
        if (!this.internalData.hasOwnProperty(primaryKey))
            return assert(function (warn) { return warn.INTERNAL_DATA_NOT_FOUND; }, decrement ? 'decrement' : 'increment');
        var currentData = Object.assign({}, this.internalData[primaryKey]);
        if (!validateNumber(amount, currentData[property]))
            return assert(function (warn) { return warn.PROPERTY_NOT_A_NUMBER; }, decrement ? 'decrement' : 'increment');
        if (decrement)
            currentData[property] -= amount;
        else
            currentData[property] += amount;
        this.global.ingest({
            type: JobType.INTERNAL_DATA_MUTATION,
            collection: this.name,
            property: primaryKey,
            value: currentData
        });
    };
    Collection.prototype.decrement = function (primaryKey, property, amount) {
        this.increment(primaryKey, property, amount, true);
    };
    Collection.prototype.delete = function (primaryKeys) {
        if (!Array.isArray(primaryKeys))
            primaryKeys = [primaryKeys];
        for (var i = 0; i < primaryKeys.length; i++) {
            var primaryKey = primaryKeys[i];
            this.global.ingest({
                type: JobType.DELETE_INTERNAL_DATA,
                collection: this.name,
                property: primaryKey
            });
        }
    };
    // remove all dynamic indexes, empty all indexes, delete all internal data
    Collection.prototype.purge = function () { };
    // external functions
    Collection.prototype.watch = function (property, callback) {
        if (!this.externalWatchers[property])
            this.externalWatchers[property] = [callback];
        else
            this.externalWatchers[property].push(callback);
    };
    // deprecate
    Collection.prototype.remove = function () {
        return this.removeFromGroup.apply(this, arguments);
    };
    return Collection;
}());
//# sourceMappingURL=collection.js.map

// This file handles external components subscribing to pulse.
var SubController = /** @class */ (function () {
    function SubController(getContext) {
        this.getContext = getContext;
        this.uuid = uuid;
        this.subscribingComponentKey = 0;
        this.subscribingComponent = false;
        this.unsubscribingComponent = false;
        this.skimmingDeepReactive = false;
        this.lastAccessedDep = null;
        this.componentStore = {};
    }
    SubController.prototype.registerComponent = function (instance, config) {
        var uuid = instance.__pulseUniqueIdentifier;
        if (!uuid) {
            // generate UUID
            uuid = this.uuid();
            // inject uuid into component instance
            var componentContainer = {
                instance: instance,
                uuid: uuid,
                ready: config.waitForMount ? false : true
            };
            instance.__pulseUniqueIdentifier = uuid;
            this.componentStore[uuid] = componentContainer;
        }
        else {
            this.mount(instance);
        }
        return uuid;
    };
    SubController.prototype.mount = function (instance) { };
    SubController.prototype.unmount = function (instance) { };
    SubController.prototype.subscribePropertiesToComponents = function (properties, componentUUID) {
        // provisionally get keys of mapped data
        var provision = properties(this.getContext());
        var keys = Object.keys(provision);
        // mapData has a user defined local key, we need to include that in the subscription so we know what to update on the component later.
        this.subscribingComponentKey = 0;
        this.subscribingComponent = {
            componentUUID: componentUUID,
            keys: keys
        };
        var returnToComponent = properties(this.getContext());
        this.subscribingComponent = false;
        this.subscribingComponentKey = 0;
        return returnToComponent;
    };
    SubController.prototype.prepareNext = function (dep) {
        this.lastAccessedDep = dep;
        if (!this.skimmingDeepReactive)
            this.subscribingComponentKey++;
    };
    SubController.prototype.foundDeepReactive = function () {
        this.skimmingDeepReactive = true;
        // undo changes
        this.lastAccessedDep.subscribers.pop();
        this.subscribingComponentKey--;
    };
    SubController.prototype.exitDeepReactive = function () {
        this.skimmingDeepReactive = false;
        //redo changes
        this.lastAccessedDep.subscribe();
        this.subscribingComponentKey++;
    };
    return SubController;
}());
//# sourceMappingURL=subController.js.map

var Storage = /** @class */ (function () {
    function Storage(storageType, storageMethods) {
        if (storageType === void 0) { storageType = "localStorage"; }
        if (storageMethods === void 0) { storageMethods = {}; }
        this.storageType = storageType;
        this.storageMethods = storageMethods;
        this.isPromise = false;
        this.storageReady = false;
        if (this.localStorageAvaliable() && storageType === "localStorage") {
            this.storageReady = true;
            storageMethods.get = localStorage.getItem.bind(localStorage);
            storageMethods.set = localStorage.setItem.bind(localStorage);
            storageMethods.remove = localStorage.removeItem.bind(localStorage);
        }
        else {
            this.storageType = "custom";
            if (this.check(storageMethods.get) &&
                this.check(storageMethods.set) &&
                this.check(storageMethods.remove)) {
                this.storageReady = true;
                if (storageMethods.async)
                    this.isPromise = true;
            }
            else {
                this.storageReady = false;
                // bad
            }
        }
    }
    Storage.prototype.get = function (collection, key) {
        var _this = this;
        if (!this.storageReady)
            return;
        if (this.isPromise) {
            return new Promise(function (resolve, reject) {
                _this.storageMethods
                    .get(_this.getKey(collection, key))
                    .then(function (res) {
                    if (typeof res !== "string")
                        return resolve(res);
                    resolve(JSON.parse(res));
                })
                    .catch(reject);
            });
        }
        else {
            return this.storageMethods.get(this.getKey(collection, key));
        }
    };
    Storage.prototype.set = function (collection, key, value) {
        if (!this.storageReady)
            return;
        this.storageMethods.set(this.getKey(collection, key), typeof value === "string" ? value : JSON.stringify(value));
    };
    Storage.prototype.remove = function (collection, key) {
        if (!this.storageReady)
            return;
        this.storageMethods.remove(this.getKey(collection, key));
    };
    Storage.prototype.getKey = function (collection, key) {
        return "_" + collection + "_" + key;
    };
    Storage.prototype.check = function (func) {
        return typeof func !== "function";
    };
    Storage.prototype.localStorageAvaliable = function () {
        try {
            localStorage.setItem("_", "_");
            localStorage.removeItem("_");
            return true;
        }
        catch (e) {
            return false;
        }
    };
    return Storage;
}());
//# sourceMappingURL=storage.js.map

var Request = /** @class */ (function (_super) {
    __extends(Request, _super);
    function Request(global, requestConfig) {
        var _this = this;
        // Before we invoke the parent class, we define some defaults
        var groups = [];
        var persist = ['baseURL'];
        var data = {
            baseURL: requestConfig.baseURL || '',
            mode: 'cors',
            credentials: 'same-origin',
            headers: {
                Accept: 'application/json'
            }
        };
        if (requestConfig.headers)
            Object.keys(requestConfig.headers).forEach(function (header) {
                data.headers[header] = requestConfig.headers[header];
            });
        if (requestConfig.credentials)
            data.credentials = requestConfig.credentials;
        if (requestConfig.mode)
            data.mode = requestConfig.mode;
        _this = _super.call(this, 'request', global, { groups: groups, data: data, persist: persist }) || this;
        _this.requestIntercept = requestConfig.requestIntercept;
        _this.responseIntercept = requestConfig.responseIntercept;
        _this.timeout = requestConfig.timeout;
        _this.saveHistory =
            typeof requestConfig.saveHistory === 'undefined' ? true : false;
        _this.global.request = {
            get: _this.get.bind(_this),
            post: _this.post.bind(_this),
            put: _this._put.bind(_this),
            patch: _this.patch.bind(_this),
            delete: _this.delete.bind(_this),
            queryify: _this.queryify.bind(_this)
        };
        return _this;
    }
    Request.prototype.get = function (url, headers) {
        return this.send(url, 'get', {}, headers);
    };
    Request.prototype.post = function (url, body, headers) {
        return this.send(url, 'post', body, headers);
    };
    Request.prototype._put = function (url, body, headers) {
        return this.send(url, 'put', body, headers);
    };
    Request.prototype.patch = function (url, body, headers) {
        return this.send(url, 'patch', body, headers);
    };
    Request.prototype.delete = function (url, body, headers) {
        return this.send(url, 'delete', body, headers);
    };
    Request.prototype.send = function (url, method, body, headers) {
        if (body === void 0) { body = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestHeaders, fullURL, options, response, contentType, final, keys, i, property;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        requestHeaders = Object.assign({}, this.public.object.headers);
                        if (headers)
                            Object.keys(headers).forEach(function (header) {
                                requestHeaders[header] = headers[header];
                            });
                        // If method is not get set application type
                        if (method !== 'get' && requestHeaders['Content-Type'] === undefined)
                            requestHeaders['Content-Type'] = 'application/json';
                        if (url.startsWith('http'))
                            fullURL = url;
                        else
                            fullURL = this.public.object.baseURL + "/" + url;
                        // Stringify body
                        body = JSON.stringify(body);
                        // Build options
                        this.options = {};
                        this.options.credentials = this.public.object.credentials;
                        this.options.mode = this.public.object.mode;
                        options = Object.assign({
                            headers: requestHeaders,
                            method: method.toUpperCase(),
                            body: method === 'get' ? null : body
                        }, this.options);
                        if (this.requestIntercept)
                            this.requestIntercept(this.global.getContext(), options);
                        if (!this.timeout) return [3 /*break*/, 2];
                        return [4 /*yield*/, Promise.race([
                                fetch(fullURL, options),
                                new Promise(function (resolve, reject) {
                                    return setTimeout(function () { return reject('timeout'); }, _this.timeout);
                                })
                            ])];
                    case 1:
                        response = _a.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, fetch(fullURL, options)];
                    case 3:
                        response = _a.sent();
                        _a.label = 4;
                    case 4:
                        contentType = response.headers.get('content-type');
                        if (!(contentType && contentType.indexOf('application/json') !== -1)) return [3 /*break*/, 6];
                        return [4 /*yield*/, response.json()];
                    case 5:
                        body = _a.sent();
                        return [3 /*break*/, 8];
                    case 6: return [4 /*yield*/, response.text()];
                    case 7:
                        body = _a.sent();
                        _a.label = 8;
                    case 8:
                        // history
                        if (!this.saveHistory)
                            this.collect({
                                id: Date.now(),
                                status: response.status,
                                timestamp: new Date(),
                                response: body
                            });
                        // If reponse body is an object, create a custom object with response function in prototype, so headers and the full response data can be accessed outside of this class
                        if (!Array.isArray(body) && typeof body === 'object') {
                            final = Object.create({
                                response: function () {
                                    return response;
                                }
                            });
                            keys = Object.keys(body);
                            for (i = 0; i < keys.length; i++) {
                                property = keys[i];
                                final[property] = body[property];
                            }
                            // if the body is not an object, we can not inject a prototype, so just return the rew body
                        }
                        else {
                            final = body;
                        }
                        // intercept response
                        if (this.responseIntercept) {
                            response.data = body;
                            this.responseIntercept(this.global.getContext(), response);
                        }
                        // reject if bad response status
                        if (response.ok || response.redirected)
                            return [2 /*return*/, final];
                        // resolve response
                        throw final;
                }
            });
        });
    };
    // Adapted from: https://github.com/Gozala/querystring/blob/master/encode.js
    Request.prototype.queryify = function (obj) {
        var stringifyPrimitive = function (value) {
            switch (typeof value) {
                case 'string':
                    return value;
                case 'boolean':
                    return value ? 'true' : 'false';
                case 'number':
                    return isFinite(value) ? value : '';
                default:
                    return '';
            }
        };
        // validate input
        if (typeof obj != 'object')
            return;
        return Object.keys(obj)
            .map(function (key) {
            var encodedKey = encodeURIComponent(stringifyPrimitive(key)) + '=';
            // if value is an array, encode with same key as parent
            if (Array.isArray(obj[key]))
                return obj[key]
                    .map(function (value) {
                    return encodedKey + encodeURIComponent(stringifyPrimitive(value));
                })
                    .join('&');
            // join encoded key with value
            return encodedKey + encodeURIComponent(stringifyPrimitive(obj[key]));
        })
            .join('&');
    };
    return Request;
}(Collection));
//# sourceMappingURL=request.js.map

var Request$1 = /** @class */ (function (_super) {
    __extends(Request, _super);
    function Request(global, root) {
        if (root === void 0) { root = {}; }
        var _this = this;
        root = Object.assign({}, root);
        delete root.collections;
        delete root.request;
        if (!root.data)
            root.data = {};
        if (!root.persist)
            root.persist = [];
        root.data["isAuthenticated"] = false;
        root.data["appReady"] = false;
        root.persist.push("isAuthenticated");
        console.log(root);
        _this = _super.call(this, "base", global, root) || this;
        return _this;
    }
    return Request;
}(Collection));
//# sourceMappingURL=base.js.map

// This file tracks and handles miscellaneous relationships between:
var RelationController = /** @class */ (function () {
    function RelationController(
    // collections refrence
    global) {
        this.global = global;
        this.groupRelations = {};
        this.dataRelationsToComputed = {};
    }
    // Called inside "findById" and potentially other functions that allow data to be related to Computed properties
    RelationController.prototype.createInternalDataRelation = function (collectionName, primaryKey, computedInstance) {
        var key = collectionName + "/" + primaryKey;
        var relations = this.dataRelationsToComputed[key];
        if (Array.isArray(relations))
            relations.push(computedInstance);
        else
            this.dataRelationsToComputed[key] = [computedInstance];
    };
    // Called when internal data has been modified. It checks to see if any computed relations exist for that data.
    // If found, ingest the computed instance into the job queue.
    RelationController.prototype.internalDataModified = function (collection, primaryKey) {
        var _this = this;
        var key = collection + "/" + primaryKey;
        if (this.dataRelationsToComputed[key]) {
            this.dataRelationsToComputed[key].forEach(function (computedIntance) {
                // ingest instance
                _this.global.ingest({
                    type: JobType.COMPUTED_REGEN,
                    collection: collection,
                    property: computedIntance,
                    dep: _this.global.getDep(computedIntance.collection, computedIntance.name)
                });
            });
        }
    };
    // Computed functions that include "findById" will need to cleanup their relations since output of findById (the data to relate to) has probably changed)
    RelationController.prototype.computedCleanup = function (computed) {
        var _this = this;
        var relationKeys = Object.keys(this.dataRelationsToComputed);
        var _loop_1 = function (i) {
            var relationKey = relationKeys[i];
            var relations = this_1.dataRelationsToComputed[relationKey];
            relations.forEach(function (computedInstance, index) {
                if (computedInstance === computed) {
                    relations.length > 1
                        ? relations.splice(index, 1)
                        : delete _this.dataRelationsToComputed[relationKey];
                }
            });
        };
        var this_1 = this;
        for (var i = 0; i < relationKeys.length; i++) {
            _loop_1(i);
        }
    };
    return RelationController;
}());

var Library = /** @class */ (function () {
    function Library(root) {
        var _this = this;
        this._private = {
            runtime: null,
            events: {},
            global: {
                config: root.config,
                initComplete: false,
                runningAction: false,
                runningWatcher: false,
                runningComputed: false,
                collecting: false,
                subs: new SubController(this.getContext.bind(this)),
                relations: null,
                storage: null,
                dispatch: this.dispatch.bind(this),
                getInternalData: this.getInternalData.bind(this),
                getContext: this.getContext.bind(this),
                createForeignGroupRelation: this.createForeignGroupRelation.bind(this),
                contextRef: {},
                getDep: this.getDep.bind(this),
                uuid: uuid
            }
        };
        ['utils', 'services', 'staticData'].forEach(function (type) {
            if (root[type])
                _this[type] = root[type];
        });
        this._private.global.storage = new Storage();
        this._private.global.relations = new RelationController(this._private.global);
        this.initCollections(root);
        this.initRuntime();
        this.bindCollectionPublicData();
        this.runAllComputed();
        this._private.global.initComplete = true;
        console.log('INIT COMPLETE', Object.assign({}, this));
        if (!this._private.global.config.ssr) {
            try {
                window._pulse = this;
            }
            catch (e) { }
        }
    }
    Library.prototype.runAllComputed = function () {
        var collectionKeys = Object.keys(this._private.collections);
        for (var i = 0; i < collectionKeys.length; i++) {
            var collection = this._private.collections[collectionKeys[i]];
            var computedKeys = collection.keys.computed;
            for (var i_1 = 0; i_1 < computedKeys.length; i_1++) {
                var computedName = computedKeys[i_1];
                this._private.runtime.performComputedOutput({
                    collection: collection.name,
                    property: computedName,
                    type: JobType.COMPUTED_REGEN
                });
                collection.runWatchers(computedName);
            }
        }
    };
    Library.prototype.getInternalData = function (collection, primaryKey) {
        return this._private.collections[collection].findById(primaryKey);
    };
    Library.prototype.getDep = function (collection, name) {
        return this._private.collections[collection].public.getDep(name);
    };
    Library.prototype.initCollections = function (root) {
        this._private.collections = {};
        var collectionKeys = Object.keys(root.collections);
        for (var i = 0; i < collectionKeys.length; i++) {
            var collection = root.collections[collectionKeys[i]];
            this._private.collections[collectionKeys[i]] = new Collection(collectionKeys[i], this._private.global, collection);
        }
        if (this._private.global.config.enableRequest !== false)
            this._private.collections['request'] = new Request(this._private.global, root.request || {});
        if (this._private.global.config.enableBase !== false)
            this._private.collections['base'] = new Request$1(this._private.global, root);
    };
    Library.prototype.initRuntime = function () {
        this._private.runtime = new Runtime(this._private.collections, this._private.global);
    };
    Library.prototype.bindCollectionPublicData = function () {
        var collectionKeys = Object.keys(this._private.collections);
        for (var i = 0; i < collectionKeys.length; i++) {
            var collection = this._private.collections[collectionKeys[i]];
            this._private.global.contextRef[collectionKeys[i]] =
                collection.public.object;
            this[collectionKeys[i]] = collection.public.object;
        }
    };
    Library.prototype.dispatch = function (type, payload) {
        switch (type) {
            case 'mutation':
                this._private.runtime.ingest({
                    type: JobType.PUBLIC_DATA_MUTATION,
                    collection: payload.collection,
                    property: payload.key,
                    value: payload.value,
                    dep: payload.dep
                });
                break;
            default:
                break;
        }
    };
    Library.prototype.getContext = function (collection) {
        var c = this._private.collections[collection];
        if (!c)
            return this._private.global.contextRef;
        return __assign({}, this._private.global.contextRef, c.methods, { data: c.public.object, indexes: c.indexes.object, groups: c.public.object, computed: c.public.object, routes: c.public.object.routes });
    };
    Library.prototype.install = function (Vue) {
        var pulse = this;
        var config = pulse._private.global.config;
        Vue.mixin({
            beforeCreate: function () {
                var _this = this;
                Object.keys(pulse._private.global.contextRef).forEach(function (collection) {
                    _this['$' + collection] = pulse._private.global.contextRef[collection];
                });
                if (pulse.utils)
                    this.$utils = pulse.utils;
                if (pulse.services)
                    this.$services = pulse.services;
                if (pulse.staticData)
                    this.$staticData = pulse.staticData;
                this.mapData = function (properties) {
                    return pulse.mapData(properties, _this, {
                        waitForMount: config.waitForMount
                    }, pulse);
                };
            },
            mounted: function () {
                if (this.__pulseUniqueIdentifier && config.waitForMount)
                    pulse.mount(this);
            },
            beforeDestroy: function () {
                if (this.__pulseUniqueIdentifier && config.autoUnmount)
                    pulse.unmount(this);
            }
        });
    };
    Library.prototype.mount = function (instance) {
        var component = this._private.global.subs.componentStore[instance.__pulseUniqueIdentifier];
        if (component) {
            component.instance = instance;
            component.ready = true;
        }
    };
    Library.prototype.mapData = function (properties, instance, _config, pulseAlias) {
        if (instance === void 0) { instance = {}; }
        if (_config === void 0) { _config = {}; }
        var pulse = pulseAlias ? pulseAlias : this;
        var config = __assign({ waitForMount: true }, _config);
        var componentUUID = pulse._private.global.subs.registerComponent(instance, config);
        // new cool mapData method
        if (typeof properties === 'function') {
            return pulse._private.global.subs.subscribePropertiesToComponents(properties, componentUUID);
            // legacy support....
        }
        else if (typeof properties === 'object') {
            var returnData_1 = {};
            normalizeMap(properties).forEach(function (_a) {
                var key = _a.key, val = _a.val;
                var collection = val.split('/')[0];
                var property = val.split('/')[1];
                var c = pulse._private.global.getContext()[collection];
                returnData_1[key] = pulse._private.global.subs.subscribePropertiesToComponents(function () {
                    var _a;
                    return _a = {}, _a[key] = c[property], _a;
                }, componentUUID)[key];
            });
            return returnData_1;
        }
    };
    Library.prototype.createForeignGroupRelation = function (foreignCollection, foreignData, dependentCollection, dependentGroup) {
        this._private.collections[foreignCollection].foreignGroupRelations[foreignData] = {
            collection: dependentCollection,
            groupToRegen: dependentGroup
        };
    };
    Library.prototype.emit = function (name, payload) {
        if (this._private.events[name])
            for (var i = 0; i < this._private.events[name].length; i++) {
                var callback = this._private.events[name][i];
                callback(payload);
            }
    };
    Library.prototype.on = function (name, callback) {
        if (!Array.isArray(this._private.events[name]))
            this._private.events[name] = [callback];
        else
            this._private.events[name].push(callback);
    };
    return Library;
}());
//# sourceMappingURL=library.js.map

export default Library;
//# sourceMappingURL=pulse.esm.min.js.map
