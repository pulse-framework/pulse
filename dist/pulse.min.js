(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.Pulse = factory());
}(this, function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    var protectedNames = [
        'data',
        'indexes',
        'groups',
        'computed',
        'actions',
        'routes'
    ];
    var collectionFunctions = [
        'collect',
        'replaceIndex',
        'getGroup',
        'newGroup',
        'deleteGroup',
        'removeFromGroup',
        'update',
        'increment',
        'decrement',
        'delete',
        'purge',
        'watch',
        'findById',
        'put',
        'move',
        'throttle',
        // deprecated
        'remove'
    ];
    function defineConfig(config, defaults) {
        return __assign({}, defaults, config);
    }
    function parse(key) {
        if (typeof key !== 'string')
            debugger;
        var primaryKey = key.split('/')[1];
        var canBeNumber = Number(primaryKey);
        if (canBeNumber !== NaN)
            primaryKey = canBeNumber;
        return {
            collection: key.split('/')[0],
            primaryKey: primaryKey
        };
    }
    function uuid() {
        return (Math.random()
            .toString()
            .split('.')[1] + Date.now());
    }
    function objectLoop(object, callback, keys) {
        var objectKeys = keys ? keys : Object.keys(object);
        for (var i = 0; i < objectKeys.length; i++) {
            var key_1 = objectKeys[i];
            var value = object[key_1];
            callback(key_1, value, objectKeys);
        }
    }
    // const thing = {}
    // objectLoop(thing, (thingKey, thingItem) => {
    // })
    function log(value, payload) {
        // console.log(`Pulse / ${value}`, payload ? payload : ' ');
    }
    function key(collection, property) {
        return collection + "/" + property;
    }
    function normalizeMap(map) {
        return Array.isArray(map)
            ? map.map(function (key) { return ({ key: key, val: key }); })
            : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); });
    }
    var arrayFunctions = [
        'push',
        'pop',
        'shift',
        'unshift',
        'splice',
        'sort',
        'reverse'
    ];
    function assert(func, funcName) {
        function warn(message) {
            // if (funcName) console.log(`PULSE // "${funcName}()" :: ${message}`);
            // else console.warn(`PULSE :: ${message}`);
            return false;
        }
        var warnings = {
            NO_PRIMARY_KEY: function () { return warn(); },
            INVALID_PARAMETER: function () { return warn(); },
            INDEX_NOT_FOUND: function () { return warn(); },
            INTERNAL_DATA_NOT_FOUND: function () { return warn(); },
            PROPERTY_NOT_A_NUMBER: function () { return warn(); }
        };
        return func(warnings)();
    }
    function isWatchableObject(value) {
        function isHTMLElement(obj) {
            try {
                return obj instanceof HTMLElement;
            }
            catch (e) {
                return (typeof obj === 'object' &&
                    obj.nodeType === 1 &&
                    typeof obj.style === 'object' &&
                    typeof obj.ownerDocument === 'object');
            }
        }
        var type = typeof value;
        return (value != null &&
            type == 'object' &&
            !isHTMLElement(value) &&
            !Array.isArray(value));
    }
    function validateNumber(mutable, amount) {
        if (typeof amount !== 'number' || typeof mutable !== 'number') {
            return false;
        }
        return true;
    }
    //# sourceMappingURL=helpers.js.map

    var JobType;
    (function (JobType) {
        JobType["PUBLIC_DATA_MUTATION"] = "PUBLIC_DATA_MUTATION";
        JobType["INTERNAL_DATA_MUTATION"] = "INTERNAL_DATA_MUTATION";
        JobType["INDEX_UPDATE"] = "INDEX_UPDATE";
        JobType["COMPUTED_REGEN"] = "COMPUTED_REGEN";
        JobType["GROUP_UPDATE"] = "GROUP_UPDATE";
        JobType["DELETE_INTERNAL_DATA"] = "DELETE_INTERNAL_DATA";
    })(JobType || (JobType = {}));
    var Runtime = /** @class */ (function () {
        function Runtime(collections, global) {
            this.collections = collections;
            this.global = global;
            this.running = false;
            this.updatingSubscribers = false;
            this.ingestQueue = [];
            this.completedJobs = [];
            this.archivedJobs = [];
            global.ingest = this.ingest.bind(this);
            this.config = global.config;
        }
        // The primary entry point for Runtime, all jobs should come through here
        Runtime.prototype.ingest = function (job) {
            this.ingestQueue.push(job);
            if (!this.running) {
                this.findNextJob();
            }
        };
        Runtime.prototype.findNextJob = function () {
            this.running = true;
            // shift the next job from the queue
            var next = this.ingestQueue.shift();
            if (!next.dep)
                // groups, computed and indexes will not have their Dep class, so get it.
                next.dep = this.global.getDep(next.property, next.collection);
            // execute the next task in the queue
            this.performJob(next);
        };
        Runtime.prototype.performJob = function (job) {
            var _this = this;
            switch (job.type) {
                case JobType.PUBLIC_DATA_MUTATION:
                    this.performPublicDataUpdate(job);
                    this.collections[job.collection].runWatchers(job.property);
                    break;
                case JobType.INTERNAL_DATA_MUTATION:
                    this.performInternalDataUpdate(job);
                    break;
                case JobType.INDEX_UPDATE:
                    this.performIndexUpdate(job);
                    break;
                case JobType.COMPUTED_REGEN:
                    this.performComputedOutput(job);
                    this.collections[job.collection].runWatchers(job.property.name);
                    break;
                case JobType.GROUP_UPDATE:
                    this.performGroupRebuild(job);
                    this.collections[job.collection].runWatchers(job.property);
                    break;
                case JobType.DELETE_INTERNAL_DATA:
                    this.performInternalDataDeletion(job);
                    break;
                default:
                    break;
            }
            // unpack dependents
            if (job.dep && job.dep.dependents.size > 0) {
                // log(`Queueing ${dep.dependents.size} dependents`);
                job.dep.dependents.forEach(function (computed) {
                    // get dep from public computed output
                    _this.ingest({
                        type: JobType.COMPUTED_REGEN,
                        collection: computed.collection,
                        property: computed,
                        dep: _this.global.getDep(computed.name, computed.collection)
                    });
                });
            }
            this.finished();
        };
        // handle job loop flow
        Runtime.prototype.finished = function () {
            var _this = this;
            this.running = false;
            if (this.completedJobs.length > 5000)
                return;
            // If there's already more stuff in the queue, loop.
            if (this.ingestQueue.length > 0) {
                this.findNextJob();
                return;
            }
            // Wait until callstack is empty to check if we should finalise this body of work
            setTimeout(function () {
                if (_this.ingestQueue.length === 0) {
                    if (!_this.updatingSubscribers)
                        _this.compileComponentUpdates();
                    _this.cleanup();
                }
                else {
                    // loop more!
                    _this.findNextJob();
                }
            });
        };
        // ****************** Perform Functions ****************** //
        Runtime.prototype.performPublicDataUpdate = function (job) {
            this.writeToPublicObject(job.collection, 'data', job.property, job.value);
            this.completedJob(job);
        };
        Runtime.prototype.performInternalDataUpdate = function (job) {
            var _this = this;
            // if job was not ingested with a value, get the most recent value from collection database
            if (!job.value) {
                if (this.collections[job.collection].internalData[job.property])
                    job.value = this.collections[job.collection].internalData[job.property];
                // this would usually be redundant, since the data has not changed, but since the relationController has no access to the collections, but does need to trigger data to rebuild, it issues an internal data "update". It's own data has not changed, but the dynamic data related to it via populate() has.
            }
            // overwrite or insert the data into collection database saving the previous value to job.previousValue, since this.overwriteInternalData returns it.
            job.previousValue = this.overwriteInternalData(job.collection, job.property, job.value);
            // collection function handels ingesting indexes to update itself, since it waits until
            // all internal data has been ingested before handling the affected indexes
            // however for direct data modifications we should update afected indexes
            if (!this.global.collecting) {
                // affected indexes is an array of indexes that have this primary key (job.property) present.
                var affectedIndexes = this.collections[job.collection].searchIndexesForPrimaryKey(job.property);
                affectedIndexes.forEach(function (index) {
                    // since this is a singular piece of data that has changed, we do not need to
                    // rebuild the entire group, so we can soft rebuild
                    var modifiedGroup = _this.collections[job.collection].softUpdateGroupData(job.property, index);
                    _this.ingest({
                        type: JobType.GROUP_UPDATE,
                        collection: job.collection,
                        value: modifiedGroup,
                        property: index,
                        dep: _this.global.getDep(index, job.collection)
                        // we do not need a previousValue because groups are cached outputs and reversing the internal data update will do the trick
                    });
                });
            }
            this.completedJob(job);
        };
        Runtime.prototype.performInternalDataDeletion = function (job) {
            var c = this.collections[job.collection];
            // preserve previous value
            job.previousValue = __assign({}, c.internalData[job.property]);
            // delete data
            delete c.internalData[job.property];
            // find indexes affected by this data deletion
            var indexesToUpdate = this.collections[job.collection].searchIndexesForPrimaryKey(job.collection, job.property);
            // for each found index, perform index update
            for (var i = 0; i < indexesToUpdate.length; i++) {
                var indexName = indexesToUpdate[i];
                var newIndex = c.indexes.object[indexName].slice().filter(function (id) { return id !== job.property; });
                this.ingest({
                    type: JobType.INDEX_UPDATE,
                    collection: c.name,
                    property: indexName,
                    value: newIndex,
                    dep: this.global.getDep(job.property, job.collection)
                });
            }
            this.completedJob(job);
        };
        Runtime.prototype.performIndexUpdate = function (job) {
            // preserve old index
            job.previousValue = this.collections[job.collection].indexes[job.property];
            // Update Index
            this.collections[job.collection].indexes.privateWrite(job.property, job.value);
            this.completedJob(job);
            // Group must also be updated
            this.ingest({
                type: JobType.GROUP_UPDATE,
                collection: job.collection,
                property: job.property,
                dep: this.global.getDep(job.property, job.collection)
            });
        };
        Runtime.prototype.performGroupRebuild = function (job) {
            // soft group rebuilds already have a generated value, otherwise generate the value
            if (!job.value) {
                job.value = this.collections[job.collection].buildGroupFromIndex(job.property);
            }
            // TODO: trigger relaction controller to update group relations
            // this.global.relations.groupModified(job.collection, job.property);
            this.writeToPublicObject(job.collection, 'group', job.property, job.value);
            this.completedJob(job);
        };
        Runtime.prototype.performComputedOutput = function (job) {
            var computed = typeof job.property === 'string'
                ? this.collections[job.collection].computed[job.property]
                : job.property;
            job.value = computed.run();
            // Commit Update
            this.writeToPublicObject(job.collection, 'computed', computed.name, job.value);
            this.completedJob(job);
        };
        // ****************** Handlers ****************** //
        Runtime.prototype.completedJob = function (job) {
            // if action is running, save that action instance inside job payload
            job.fromAction = this.global.runningAction;
            // during runtime log completed job ready for component updates
            if (this.global.initComplete)
                this.completedJobs.push(job);
            // if data is persistable ensure storage is updated with new data
            this.persistData(job);
            // inform Dep class that the job is complete
            if (job.dep)
                job.dep.changed();
            // inform the collection that the job is complete
            this.collections[job.collection].changed(job.property);
            // if either of these contain tickets, the relation controller will ingest updates
        };
        // ****************** End Runtime Events ****************** //
        Runtime.prototype.compileComponentUpdates = function () {
            if (!this.global.initComplete)
                return;
            this.updatingSubscribers = true;
            log('ALL JOBS COMPLETE', this.completedJobs);
            var componentsToUpdate = {};
            // for all completed jobs
            for (var i = 0; i < this.completedJobs.length; i++) {
                var job = this.completedJobs[i];
                // if job has a Dep class present
                // Dep class contains subscribers to that property (as a completed job)
                if (job.dep) {
                    var subscribers = job.dep.subscribers;
                    // for all the subscribers
                    for (var i_1 = 0; i_1 < subscribers.length; i_1++) {
                        // add to componentsToUpdate (ensuring update & component is unique)
                        var uuid = subscribers[i_1].componentUUID;
                        var key = subscribers[i_1].key;
                        if (!componentsToUpdate[uuid]) {
                            componentsToUpdate[uuid] = {};
                            componentsToUpdate[uuid][key] = job.value;
                        }
                        else {
                            componentsToUpdate[uuid][key] = job.value;
                        }
                    }
                }
            }
            this.updateSubscribers(componentsToUpdate);
            this.completedJobs = [];
        };
        Runtime.prototype.updateSubscribers = function (componentsToUpdate) {
            var componentKeys = Object.keys(componentsToUpdate);
            var _loop_1 = function (i) {
                var componentID = componentKeys[i];
                var componentInstance = this_1.global.subs.componentStore[componentID];
                if (!componentInstance || !componentInstance.instance)
                    return { value: void 0 };
                var propertiesToUpdate = componentsToUpdate[componentID];
                var dataKeys = Object.keys(propertiesToUpdate);
                // Switch depending on framework
                switch (this_1.global.config.framework) {
                    case 'vue':
                        dataKeys.forEach(function (property) {
                            var value = propertiesToUpdate[property];
                            componentInstance.instance.$set(componentInstance.instance, property, value);
                        });
                        break;
                    case 'react':
                        componentInstance.instance.setState(propertiesToUpdate);
                        // console.log(propertiesToUpdate);
                        break;
                    default:
                        break;
                }
            };
            var this_1 = this;
            for (var i = 0; i < componentKeys.length; i++) {
                var state_1 = _loop_1(i);
                if (typeof state_1 === "object")
                    return state_1.value;
            }
        };
        Runtime.prototype.persistData = function (job) {
            if (job.type === JobType.INTERNAL_DATA_MUTATION)
                return;
            if (this.collections[job.collection].persist.includes(job.property)) {
                this.global.storage.set(job.collection, job.property, job.value);
            }
        };
        Runtime.prototype.cleanup = function () {
            var _this = this;
            setTimeout(function () {
                _this.updatingSubscribers = false;
            });
        };
        // ****************** Misc Handlers ****************** //
        Runtime.prototype.writeToPublicObject = function (collection, type, key, value) {
            if (type === 'indexes') {
                if (!this.collections[collection][type].object.hasOwnProperty(key))
                    return;
                this.collections[collection][type].privateWrite(key, value);
            }
            else {
                if (!this.collections[collection].public.object.hasOwnProperty(key))
                    return;
                this.collections[collection].public.privateWrite(key, value);
            }
        };
        Runtime.prototype.overwriteInternalData = function (collection, primaryKey, newData) {
            var internalData = this.collections[collection].internalData;
            // create a copy of the original data
            var currentData = internalData[primaryKey]
                ? __assign({}, internalData[primaryKey]) : false;
            if (currentData) {
                // data already exists, merge objects and return previous object
                var keys = Object.keys(newData || {});
                for (var i = 0; i < keys.length; i++) {
                    var property = keys[i];
                    internalData[primaryKey][property] = newData[property];
                }
                return currentData;
            }
            else {
                // data does not exist, write and return false
                internalData[primaryKey] = newData;
                return false;
            }
        };
        return Runtime;
    }());
    //# sourceMappingURL=runtime.js.map

    var Computed = /** @class */ (function () {
        function Computed(global, collection, name, computedFunction) {
            this.global = global;
            this.collection = collection;
            this.name = name;
            this.computedFunction = computedFunction;
            this.relatedToGroup = [];
            this.relatedToInternalData = [];
        }
        Computed.prototype.run = function () {
            this.global.runningComputed = this;
            var output = this.computedFunction(this.global.getContext(this.collection));
            if (output === undefined || output === null)
                output = false;
            this.global.runningComputed = false;
            return output;
        };
        return Computed;
    }());
    //# sourceMappingURL=computed.js.map

    var RelationTypes;
    (function (RelationTypes) {
        RelationTypes[RelationTypes["COMPUTED_DEPENDS_ON_DATA"] = 0] = "COMPUTED_DEPENDS_ON_DATA";
        RelationTypes[RelationTypes["COMPUTED_DEPENDS_ON_GROUP"] = 1] = "COMPUTED_DEPENDS_ON_GROUP";
        RelationTypes[RelationTypes["DATA_DEPENDS_ON_DEP"] = 2] = "DATA_DEPENDS_ON_DEP";
        RelationTypes[RelationTypes["DATA_DEPENDS_ON_GROUP"] = 3] = "DATA_DEPENDS_ON_GROUP";
        RelationTypes[RelationTypes["DATA_DEPENDS_ON_DATA"] = 4] = "DATA_DEPENDS_ON_DATA"; // used by findById() when run in populate()
    })(RelationTypes || (RelationTypes = {}));
    var RelationController = /** @class */ (function () {
        function RelationController(global) {
            this.global = global;
            this.relations = {};
            this.cleanupRefs = {};
        }
        RelationController.prototype.save = function (id, type, updateThis, whenThisChanges) {
            this.relations[id] = {
                type: type,
                updateThis: updateThis,
                whenThisChanges: whenThisChanges
            };
        };
        RelationController.prototype.cleanup = function (cleanupKey) {
            var _this = this;
            if (!this.cleanupRefs[cleanupKey])
                return;
            // delete relations for this cleanupKey based on the tickets saved
            this.cleanupRefs[cleanupKey].forEach(function (ticket) {
                var whenThisChanges = _this.relations[ticket].whenThisChanges;
                if (typeof whenThisChanges !== 'string')
                    return;
                _this.global.cleanupTickets(whenThisChanges);
                delete _this.relations[ticket];
            });
            // empty old tickets ready for new evaluation
            this.cleanupRefs[cleanupKey] = [];
        };
        RelationController.prototype.saveTicketsByCleanupKey = function (cleanupKey, ticket) {
            if (Array.isArray(this.cleanupRefs[cleanupKey]))
                this.cleanupRefs[cleanupKey].push(ticket);
            // create new array with ticket already inside
            else
                this.cleanupRefs[cleanupKey] = [ticket];
        };
        RelationController.prototype.relate = function (type, updateThis, whenThisChanges, collection // needed for data relations
        ) {
            // a unique identifier for this relation increases speed finding & cleaning up relations
            var ticket = uuid();
            // if collection is set we change whenThisChanges (expected as a primaryKey)
            // to be a key with the collection/key
            if (collection)
                whenThisChanges = key(collection, whenThisChanges);
            // cleanup previous relations for this cleanup key
            var cleanupKey;
            // cleanup key is already set
            if (typeof updateThis === 'string')
                cleanupKey = updateThis;
            // extract cleanup key from computed instance
            else if (updateThis instanceof Computed)
                cleanupKey = key(updateThis.collection, updateThis.name);
            // clean up
            this.cleanup(cleanupKey);
            // new cleanup ref
            this.saveTicketsByCleanupKey(cleanupKey, ticket);
            switch (type) {
                // used to relate the result of findById() when used in a Computed method
                case RelationTypes.COMPUTED_DEPENDS_ON_DATA:
                    this.global.ticket(collection, ticket, whenThisChanges); // for update
                    this.save(ticket, type, updateThis, whenThisChanges);
                    break;
                // used to relate the result of getGroup() when used in a Computed method
                case RelationTypes.COMPUTED_DEPENDS_ON_GROUP:
                    this.global.ticket(collection, ticket, whenThisChanges);
                    this.save(ticket, type, updateThis, whenThisChanges);
                    break;
                // used to relate the result of findById() when used in populate()
                case RelationTypes.DATA_DEPENDS_ON_DATA:
                    this.global.ticket(collection, ticket, whenThisChanges);
                    this.save(ticket, type, updateThis, whenThisChanges);
                    break;
                // used to relate the result of getGroup() when used in populate()
                case RelationTypes.DATA_DEPENDS_ON_GROUP:
                    this.global.ticket(collection, ticket, whenThisChanges);
                    this.save(ticket, type, updateThis, whenThisChanges);
                    break;
                //
                case RelationTypes.DATA_DEPENDS_ON_DEP:
                    whenThisChanges.ticket(ticket);
                    this.save(ticket, type, updateThis, whenThisChanges);
                    break;
            }
        };
        // this should be called whenever the whenThisChanges value updates
        RelationController.prototype.update = function (tickets) {
            var _this = this;
            tickets.forEach(function (ticket) {
                var relation = _this.relations[ticket];
                switch (relation.type) {
                    //
                    case RelationTypes.COMPUTED_DEPENDS_ON_DATA:
                        _this.ingestComputed(relation.updateThis);
                        break;
                    //
                    case RelationTypes.COMPUTED_DEPENDS_ON_GROUP:
                        _this.ingestComputed(relation.updateThis);
                        break;
                    //
                    case RelationTypes.DATA_DEPENDS_ON_DATA:
                        _this.ingestDataUpdate(relation.updateThis);
                        break;
                    //
                    case RelationTypes.DATA_DEPENDS_ON_GROUP:
                        _this.ingestDataUpdate(relation.updateThis);
                        break;
                    //
                    case RelationTypes.DATA_DEPENDS_ON_DEP:
                        // console.log('HAHAHA', relation);
                        var parsed = parse(relation.updateThis);
                        _this.global.ingest({
                            type: JobType.INTERNAL_DATA_MUTATION,
                            collection: parsed.collection,
                            property: parsed.primaryKey
                        });
                        break;
                }
            });
        };
        RelationController.prototype.ingestComputed = function (computed) {
            this.global.ingest({
                type: JobType.COMPUTED_REGEN,
                collection: computed.collection,
                property: computed.name,
                dep: this.global.getDep(computed.name, computed.collection)
            });
        };
        RelationController.prototype.ingestDataUpdate = function (updateThis) {
            var parsed = parse(updateThis);
            this.global.ingest({
                type: JobType.INTERNAL_DATA_MUTATION,
                collection: parsed.collection,
                property: parsed.primaryKey
            });
        };
        return RelationController;
    }());
    //# sourceMappingURL=relationController.js.map

    var Dep = /** @class */ (function () {
        function Dep(global, name, rootProperty, propertyOnObject) {
            this.global = global;
            this.name = name;
            this.rootProperty = rootProperty;
            this.propertyOnObject = propertyOnObject;
            this.dependents = new Set();
            this.subscribers = [];
            this.tickets = [];
        }
        Dep.prototype.register = function () {
            var subs = this.global.subs;
            if (this.global.runningComputed) {
                this.dependents.add(this.global.runningComputed);
            }
            if (this.global.runningPopulate) {
                this.global.relations.relate(RelationTypes.DATA_DEPENDS_ON_DEP, this.global.runningPopulate, this);
            }
            if (subs.subscribingComponent) {
                this.subscribeComponent();
            }
            if (subs.unsubscribingComponent) ;
        };
        Dep.prototype.subscribeComponent = function () {
            var subs = this.global.subs;
            if (this.rootProperty && subs.skimmingDeepReactive) {
                subs.prepareNext(this);
                return;
            }
            if (this.rootProperty) {
                subs.foundDeepReactive();
                subs.prepareNext(this);
                return;
            }
            if (!this.rootProperty && subs.skimmingDeepReactive) {
                subs.exitDeepReactive();
            }
            this.subscribe();
            subs.prepareNext(this);
        };
        Dep.prototype.subscribe = function () {
            var subs = this.global.subs;
            var keys = subs.subscribingComponent.keys;
            var key = keys[subs.subscribingComponentKey];
            var component = {
                componentUUID: subs.subscribingComponent.componentUUID,
                key: key
            };
            this.subscribers.push(component);
        };
        Dep.prototype.ticket = function (uuid) {
            this.tickets.push(uuid);
        };
        // this should fire once runtime finish a job with a dep,
        // we can then loop back with the relationController to check
        // for any active relations based on tickets saved in this dep class
        Dep.prototype.changed = function () {
            if (this.tickets.length > 0) {
                this.global.relations.update(this.tickets.slice());
            }
        };
        return Dep;
    }());
    //# sourceMappingURL=dep.js.map

    var Reactive = /** @class */ (function () {
        function Reactive(object, global, collection, mutable, type) {
            if (object === void 0) { object = {}; }
            this.global = global;
            this.collection = collection;
            this.mutable = mutable;
            this.type = type;
            this.allowPrivateWrite = false;
            this.touching = false;
            this.dispatch = this.global.dispatch;
            this.properties = Object.keys(object);
            this.object = this.reactiveObject(object);
        }
        Reactive.prototype.reactiveObject = function (object, rootProperty) {
            var self = this;
            var objectKeys = Object.keys(object);
            var _loop_1 = function (i) {
                var key = objectKeys[i];
                var rootProperty_1 = object.rootProperty;
                var currentProperty = key;
                var value = object[key];
                // If property is an array, make it reactive
                if (Array.isArray(value)) ;
                else if (isWatchableObject(value) && !protectedNames.includes(key)) {
                    // rootProperty should be the current key if first deep object
                    value = this_1.deepReactiveObject(value, rootProperty_1 || key, currentProperty);
                }
                // Create an instance of the dependency tracker
                var dep = new Dep(this_1.global, key, rootProperty_1, currentProperty);
                Object.defineProperty(object, key, {
                    get: function pulseGetter() {
                        if (self.sneaky)
                            return value;
                        if (self.global.touching) {
                            self.global.touched = dep;
                            return;
                        }
                        dep.register();
                        // to prevent Vue from destorying our deep getters / setters
                        if (self.global.mappingData && isWatchableObject(value))
                            return Object.assign({}, value);
                        return value;
                    },
                    set: function pulseSetter(newValue) {
                        // DEEP REACTIVE handler: "rootProperty" indicates if the object is "deep".
                        if (rootProperty_1 && self.mutable.includes(rootProperty_1)) {
                            // mutate locally
                            value = newValue;
                            // dispatch mutation for rootProperty
                            self.dispatch('mutation', {
                                collection: self.collection,
                                key: rootProperty_1,
                                value: self.object[rootProperty_1],
                                dep: dep
                            });
                            // Regular muations
                        }
                        else {
                            // if backdoor open or is protected name, allow direct mutation
                            if (self.allowPrivateWrite || protectedNames.includes(key)) {
                                // dynamically convert new values to reactive if objects
                                if (isWatchableObject(value)) {
                                    newValue = self.deepReactiveObject(newValue, rootProperty_1 || key, currentProperty);
                                }
                                return (value = newValue);
                            }
                            // if property is mutable dispatch update
                            if (self.mutable.includes(key)) {
                                self.dispatch('mutation', {
                                    collection: self.collection,
                                    key: key,
                                    value: newValue,
                                    dep: dep
                                });
                                // we did not apply the mutation since runtime will privatly
                                // write the result since we dispatched above
                            }
                        }
                    }
                });
            };
            var this_1 = this;
            // Loop over all properties of the to-be reactive object
            for (var i = 0; i < objectKeys.length; i++) {
                _loop_1(i);
            }
            return object;
        };
        Reactive.prototype.deepReactiveObject = function (value, rootProperty, propertyOnObject) {
            var objectWithCustomPrototype = Object.create({
                rootProperty: rootProperty,
                propertyOnObject: propertyOnObject
            });
            // repopulate custom object with incoming values
            var keys = Object.keys(value);
            for (var i = 0; i < keys.length; i++) {
                var property = keys[i];
                objectWithCustomPrototype[property] = value[property];
            }
            this.allowPrivateWrite = true;
            var obj = this.reactiveObject(objectWithCustomPrototype, rootProperty);
            this.allowPrivateWrite = false;
            return obj;
        };
        Reactive.prototype.reactiveArray = function (array, key) {
            var self = this;
            var reactiveArray = array.slice();
            var _loop_2 = function (i) {
                var func = arrayFunctions[i];
                var original = Array.prototype[func];
                Object.defineProperty(reactiveArray, func, {
                    value: function () {
                        var result = original.apply(this, arguments);
                        if (self.global.initComplete)
                            self.dispatch('mutation', {
                                collection: self.collection,
                                key: key,
                                value: result
                            });
                        return result;
                    }
                });
            };
            for (var i = 0; i < arrayFunctions.length; i++) {
                _loop_2(i);
            }
            return reactiveArray;
        };
        Reactive.prototype.privateWrite = function (property, value) {
            this.allowPrivateWrite = true;
            this.object[property] = value;
            this.allowPrivateWrite = false;
        };
        // sneaky blocked the getter, sneaky.
        Reactive.prototype.privateGet = function (property) {
            this.sneaky = true;
            var data = this.object[property];
            this.sneaky = false;
            return data;
        };
        Reactive.prototype.exists = function (property) {
            this.sneaky = true;
            var bool = !!this.object.hasOwnProperty(property);
            this.sneaky = false;
            return bool;
        };
        Reactive.prototype.getKeys = function () {
            this.sneaky = true;
            var keys = Object.keys(this.object);
            this.sneaky = false;
            return keys;
        };
        return Reactive;
    }());
    // look for computed output access to determine dependencies
    // remove computed categories from public object on default config
    //# sourceMappingURL=reactive.js.map

    var Action = /** @class */ (function () {
        function Action(collection, global, action, actionName) {
            this.collection = collection;
            this.global = global;
            this.action = action;
            this.actionName = actionName;
            this.executing = false;
            this.uuid = uuid();
            this.prepare(action, global, this.global.contextRef.undo);
        }
        Action.prototype.prepare = function (action, global, undo) {
            var _this = this;
            this.exec = function () {
                var _this_1 = this;
                var context = global.getContext(_this.collection);
                context.undo = function (error) {
                    return undo(_this_1.actionName, _this_1.uuid, error);
                };
                global.runningAction = _this;
                _this.executing = true;
                var result = action.apply(null, [context].concat(Array.prototype.slice.call(arguments)));
                _this.executing = false;
                global.runningAction = false;
                return result;
            };
        };
        return Action;
    }());
    //# sourceMappingURL=action.js.map

    var Collection = /** @class */ (function () {
        function Collection(name, global, root) {
            this.name = name;
            this.global = global;
            this.config = {};
            this.keys = {};
            this.methods = {};
            this.actions = {};
            this.computed = {};
            this.watchers = {};
            this.externalWatchers = {};
            this.persist = [];
            this.local = {};
            this.model = {};
            this.collectionSize = 0;
            this.primaryKey = false;
            this.internalData = {};
            this.internalDataWithPopulate = [];
            this.tickets = {};
            this.config = root.config;
            this.dispatch = this.global.dispatch;
            // legacy support ("filters" changed to "computed")
            root.computed = __assign({}, root.computed, root.filters);
            root = this.prepareNamespace(root);
            this.initReactive(root.data, root.groups);
            this.initRoutes(root.routes);
            this.initActions(root.actions);
            this.initWatchers(root.watch);
            this.initComputed(root.computed);
            this.initModel(root.model);
            this.initPersist(root.persist);
        }
        Collection.prototype.prepareNamespace = function (root) {
            var _this = this;
            // map collection methods
            collectionFunctions.map(function (func) { return (_this.methods[func] = _this[func].bind(_this)); });
            if (root.local)
                this.local = root.local;
            // for each type set default and register keys
            ['data', 'actions', 'computed', 'indexes', 'routes', 'watch'].forEach(function (type) {
                if (type !== 'indexes' && !root[type])
                    root[type] = {};
                _this.keys[type] =
                    type === 'indexes' ? root['groups'] || [] : Object.keys(root[type]);
            });
            // assign namespace, this is used by initReactive
            this.namespace = Object.assign(Object.create(__assign({}, this.methods)), __assign({ routes: {}, indexes: {}, actions: root.actions }, root.computed, root.data, this.normalizeGroups(root.groups)));
            return root;
        };
        // groups are defined by the user as an array of strings, this converts them into object/keys
        Collection.prototype.normalizeGroups = function (groupsAsArray) {
            if (groupsAsArray === void 0) { groupsAsArray = []; }
            var groups = {};
            for (var i = 0; i < groupsAsArray.length; i++) {
                var groupName = groupsAsArray[i];
                groups[groupName] = [];
            }
            return groups;
        };
        Collection.prototype.runWatchers = function (property) {
            var watcher = this.watchers[property];
            if (watcher)
                watcher();
            var externalWatchers = this.externalWatchers[property];
            if (externalWatchers)
                externalWatchers.forEach(function (func) {
                    return typeof func === 'function' ? func() : false;
                });
        };
        Collection.prototype.initReactive = function (data, groups) {
            if (groups === void 0) { groups = []; }
            groups = this.normalizeGroups(groups);
            // Make indexes reactive
            this.indexes = new Reactive(groups, // object
            this.global, // global
            this.name, // collection
            this.keys.indexes, // mutable
            'indexes' // type
            );
            this.namespace.indexes = this.indexes.object;
            // Make entire public object Reactive
            this.public = new Reactive(this.namespace, this.global, this.name, this.keys.data.concat(this.keys.indexes), 'root');
        };
        Collection.prototype.initPersist = function (persist) {
            var _this = this;
            if (!Array.isArray(persist))
                return;
            var _loop_1 = function (i) {
                var dataName = persist[i];
                // TODO: validate
                this_1.persist.push(dataName);
                if (this_1.global.storage.isPromise) {
                    this_1.global.storage.get(this_1.name, dataName).then(function (data) {
                        if (data === undefined || data === null)
                            return;
                        var job = {
                            type: JobType.PUBLIC_DATA_MUTATION,
                            value: data,
                            property: dataName,
                            collection: _this.name,
                            dep: _this.global.getDep(dataName, _this.name)
                        };
                        _this.global.ingest(job);
                    });
                }
                else {
                    var data = this_1.global.storage.get(this_1.name, dataName);
                    if (data === undefined || data === null)
                        return "continue";
                    this_1.public.privateWrite(dataName, data);
                }
            };
            var this_1 = this;
            for (var i = 0; i < persist.length; i++) {
                _loop_1(i);
            }
        };
        Collection.prototype.initActions = function (actions) {
            if (actions === void 0) { actions = {}; }
            var actionKeys = Object.keys(actions);
            for (var i = 0; i < actionKeys.length; i++) {
                var action = actions[actionKeys[i]];
                this.actions[actionKeys[i]] = new Action(this.name, this.global, action, actionKeys[i]);
                this.public.privateWrite(actionKeys[i], this.actions[actionKeys[i]].exec);
            }
        };
        Collection.prototype.initWatchers = function (watchers) {
            var _this = this;
            if (watchers === void 0) { watchers = {}; }
            var watcherKeys = Object.keys(watchers);
            var _loop_2 = function (i) {
                var watcher = watchers[watcherKeys[i]];
                this_2.watchers[watcherKeys[i]] = function () {
                    _this.global.runningWatcher = {
                        collection: _this.name,
                        property: watcherKeys[i]
                    };
                    var watcherOutput = watcher(_this.global.getContext(_this.name));
                    _this.global.runningWatcher = false;
                    return watcherOutput;
                };
            };
            var this_2 = this;
            for (var i = 0; i < watcherKeys.length; i++) {
                _loop_2(i);
            }
            this.watchers._keys = watcherKeys;
        };
        Collection.prototype.initComputed = function (computed) {
            var _this = this;
            objectLoop(computed, function (computedName, computedFunction) {
                _this.computed[computedName] = new Computed(_this.global, _this.name, computedName, computedFunction);
                _this.public.object[computedName] = [];
            }, this.keys.computed);
        };
        Collection.prototype.initRoutes = function (routes) {
            var _this = this;
            var self = this;
            var routeWrapped = function (routeName) {
                return function () {
                    var requestObject = Object.assign({}, self.global.request);
                    requestObject.context = self.global.getContext();
                    return routes[routeName].apply(null, [requestObject].concat(Array.prototype.slice.call(arguments)));
                };
            };
            objectLoop(routes, function (routeName) {
                return (_this.public.object.routes[routeName] = routeWrapped(routeName));
            });
        };
        Collection.prototype.initModel = function (model) {
            var _this = this;
            if (model === void 0) { model = {}; }
            this.model = model;
            Object.keys(model).forEach(function (property) {
                Object.keys(model[property]).forEach(function (config) {
                    switch (config) {
                        case 'primaryKey':
                            _this.primaryKey = property;
                            break;
                        case 'populate':
                            _this.internalDataWithPopulate.push(property);
                            break;
                    }
                });
            });
        };
        // called by relationController after new relation has been created
        Collection.prototype.ticket = function (uuid, primaryKey) {
            if (Array.isArray(this.tickets[primaryKey]))
                this.tickets[primaryKey].push(uuid);
            else
                this.tickets[primaryKey] = [uuid];
        };
        Collection.prototype.cleanupTickets = function (primaryKey) {
            if (this.tickets[primaryKey]) {
                this.tickets[primaryKey] = [];
            }
        };
        // called by Runtime when job has been completed
        Collection.prototype.changed = function (primaryKey) {
            if (this.tickets[primaryKey]) {
                this.global.relations.update(this.tickets[primaryKey]);
            }
        };
        Collection.prototype.getData = function (id) {
            return __assign({}, this.internalData[id]);
        };
        Collection.prototype.buildGroupFromIndex = function (groupName) {
            var constructedArray = [];
            // get index directly
            var index = this.indexes.privateGet(groupName);
            if (!index)
                return [];
            // for every primaryKey in the index
            for (var i = 0; i < index.length; i++) {
                // primaryKey of data
                var id = index[i];
                // copy data from internal database
                var data = this.getData(id);
                // if none found skip
                if (!data)
                    continue;
                // inject dynamic data
                data = this.injectDynamicRelatedData(id, data);
                constructedArray.push(data);
            }
            return constructedArray;
        };
        // rebuilding an entire group is expensive on resources, but is
        // not nessisary if only one piece of data has changed
        // this function will replace a single piece of data without rebuilding
        // the entire group
        Collection.prototype.softUpdateGroupData = function (primaryKey, groupName) {
            var index = this.indexes.privateGet(groupName);
            // find the data's position within index
            var position = index.indexOf(primaryKey);
            // if group is dynamic, just build the group from index.
            if (!this.public[groupName])
                return this.buildGroupFromIndex(groupName);
            // copy the current group output
            var currentGroup = [this.public[groupName]];
            // get data for primaryKey
            var data = __assign({}, this.internalData[primaryKey]);
            console.log('REBUILD SOFT', primaryKey, groupName);
            data = this.injectDynamicRelatedData(primaryKey, data);
            // replace at known position with updated data
            currentGroup[position] = data;
            return currentGroup;
        };
        // This should be called on every piece of data retrieved when building a group from an index
        Collection.prototype.injectDynamicRelatedData = function (primaryKey, data) {
            var _this = this;
            // for each populate() function found in the model for this collection
            this.internalDataWithPopulate.forEach(function (property) {
                // set runningPopulate to the key (collection/propery) of the data being modified
                // this is fed into the relations.relate() function becoming the unique cleanupKey for the relation
                _this.global.runningPopulate = key(_this.name, primaryKey);
                // run populate function passing in the context and the data
                var populated = _this.model[property].populate(_this.global.getContext(), data);
                _this.global.runningPopulate = false;
                // inject result to data
                data[property] = populated;
            });
            return data;
        };
        Collection.prototype.createGroups = function (group) {
            if (group === undefined)
                group = [];
            else if (!Array.isArray(group))
                group = [group];
            for (var i = 0; i < group.length; i++) {
                var groupName = group[i];
                if (!this.indexes.exists(groupName)) {
                    this.indexes.privateWrite(groupName, []);
                }
            }
            return group;
        };
        // METHODS
        Collection.prototype.collect = function (data, group, config) {
            var _this = this;
            config = defineConfig(config, {
                append: true
            });
            this.global.collecting = true;
            // normalise data
            if (!Array.isArray(data))
                data = [data];
            // if groups don't already exist, create them dynamically
            var groups = this.createGroups(group);
            // groups now contains just the groups directly modified by this collect
            // preserve index previous values
            var previousIndexValues = this.getPreviousIndexValues(groups);
            var indexesToRegenOnceComplete = new Set();
            // process data items
            for (var i = 0; i < data.length; i++) {
                var dataItem = data[i];
                if (dataItem === null)
                    continue;
                // process data item returns "success" as a boolean and affectedIndexes as an array
                var processDataItem = this.processDataItem(dataItem, groups, config);
                if (!processDataItem)
                    continue;
                if (processDataItem.success)
                    this.collectionSize++;
                // ensure indexes modified by this data item are waiting to be ingested for regen
                processDataItem.affectedIndexes.forEach(function (index) {
                    return indexesToRegenOnceComplete.add(index);
                });
            }
            indexesToRegenOnceComplete.forEach(function (index) {
                _this.global.ingest({
                    type: JobType.INDEX_UPDATE,
                    collection: _this.name,
                    property: index,
                    value: _this.indexes.privateGet(index),
                    previousValue: previousIndexValues[index]
                });
            });
            this.global.collecting = false;
        };
        Collection.prototype.processDataItem = function (dataItem, groups, config) {
            if (groups === void 0) { groups = []; }
            if (!this.primaryKey)
                this.findPrimaryKey(dataItem);
            if (!this.primaryKey)
                return false;
            var key = dataItem[this.primaryKey];
            // find affected indexes
            var affectedIndexes = groups.slice();
            // searchIndexesForPrimaryKey returns an array of indexes that include that primaryKey
            // for each index found, if it is not already known, add to affected indexes
            this.searchIndexesForPrimaryKey(key).map(function (index) { return !affectedIndexes.includes(index) && affectedIndexes.push(index); });
            // validate against model
            // ingest the data
            this.global.ingest({
                type: JobType.INTERNAL_DATA_MUTATION,
                collection: this.name,
                property: key,
                value: dataItem
            });
            // add the data to group indexes
            for (var i = 0; i < groups.length; i++) {
                var groupName = groups[i];
                var index = this.indexes.privateGet(groupName);
                // remove key if already present in index
                index = index.filter(function (k) { return k != key; });
                if (config.append)
                    index.push(key);
                else
                    index.unshift(key);
                // write index
                this.indexes.privateWrite(groupName, index);
            }
            return { success: true, affectedIndexes: affectedIndexes };
        };
        Collection.prototype.searchIndexesForPrimaryKey = function (primaryKey) {
            // get a fresh copy of the keys to include dynamic indexes
            var keys = this.indexes.getKeys();
            var foundIndexes = [];
            // for every index
            for (var i = 0; i < keys.length; i++) {
                var indexName = keys[i];
                // if the index includes the primaryKey
                if (this.indexes.privateGet(indexName).includes(primaryKey))
                    foundIndexes.push(indexName);
            }
            return foundIndexes;
        };
        Collection.prototype.getPreviousIndexValues = function (groups) {
            var returnData = {};
            for (var i = 0; i < groups; i++) {
                var groupName = groups[i];
                returnData[groupName] = this.indexes.privateGet(groupName);
            }
            return returnData;
        };
        Collection.prototype.findPrimaryKey = function (dataItem) {
            if (dataItem.hasOwnProperty('id'))
                this.primaryKey = 'id';
            else if (dataItem.hasOwnProperty('_id'))
                this.primaryKey = '_id';
            else if (dataItem.hasOwnProperty('key'))
                this.primaryKey = 'key';
            if (this.primaryKey)
                return true;
            else
                return assert(function (warn) { return warn.NO_PRIMARY_KEY; });
        };
        Collection.prototype.replaceIndex = function (indexName, newIndex) {
            if (!Array.isArray(newIndex) || typeof indexName !== 'string')
                return assert(function (warn) { return warn.INVALID_PARAMETER; });
            this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: this.name,
                property: indexName,
                value: newIndex
            });
        };
        Collection.prototype.findById = function (id) {
            // if (!this.internalData.hasOwnProperty(id))
            //   return assert(warn => warn.INTERNAL_DATA_NOT_FOUND, 'findById');
            if (this.global.runningComputed) {
                var computed = this.global.runningComputed;
                this.global.relations.relate(RelationTypes.COMPUTED_DEPENDS_ON_DATA, 
                // updateThis computed instance
                computed, 
                // primaryKey of data for whenThisChanges
                id, this.name);
            }
            if (this.global.runningPopulate) {
                this.global.relations.relate(RelationTypes.DATA_DEPENDS_ON_DATA, 
                // this is the key ("collection/primaryKey") for the dynamically populated data for updateThis
                this.global.runningPopulate, 
                // primaryKey of data for whenThisChanges
                id, this.name);
            }
            return this.internalData[id];
        };
        Collection.prototype.getGroup = function (property) {
            // if called inside Computed method, create temporary relation in relationship controller
            if (this.global.runningComputed) {
                var computed = this.global.runningComputed;
                this.global.relations.relate(RelationTypes.COMPUTED_DEPENDS_ON_GROUP, computed, // updateThis
                property, // whenThisChanges
                this.name);
            }
            // if called from within populate() create another temporary relation
            if (this.global.runningPopulate) {
                this.global.relations.relate(RelationTypes.DATA_DEPENDS_ON_GROUP, this.global.runningPopulate, // updateThis
                property, // whenThisChanges
                this.name);
            }
            // get group is not cached, so generate a fresh group from the index
            return this.buildGroupFromIndex(property) || [];
        };
        // action functions
        Collection.prototype.undo = function () { };
        Collection.prototype.throttle = function () { };
        // group functions
        Collection.prototype.move = function (ids, sourceIndexName, destIndexName, method) {
            if (method === void 0) { method = 'push'; }
            // validation
            if (!this.indexes.exists(sourceIndexName))
                return assert(function (warn) { return warn.INDEX_NOT_FOUND; });
            if (destIndexName && !this.indexes.exists(destIndexName))
                return assert(function (warn) { return warn.INDEX_NOT_FOUND; });
            if (!Array.isArray(ids))
                ids = [ids];
            var sourceIndex = this.indexes.privateGet(sourceIndexName);
            var _loop_3 = function (i) {
                sourceIndex.map(function (id) { return id !== ids[i]; });
            };
            for (var i = 0; i < ids.length; i++) {
                _loop_3(i);
            }
            this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: this.name,
                property: sourceIndexName,
                value: sourceIndex
            });
            if (destIndexName) {
                var destIndex = this.indexes.privateGet(destIndexName);
                for (var i = 0; i < ids.length; i++) {
                    // destIndex = destIndex.filter(k => k != ids[i]);
                    if (destIndex.includes(ids[i]))
                        continue;
                    // push or unshift id into current index
                    destIndex[method](ids[i]);
                }
                this.global.ingest({
                    type: JobType.INDEX_UPDATE,
                    collection: this.name,
                    property: destIndexName,
                    value: destIndex
                });
            }
        };
        Collection.prototype.put = function (ids, destIndexName, method) {
            if (method === void 0) { method = 'push'; }
            // validation
            if (!this.indexes.exists(destIndexName))
                return assert(function (warn) { return warn.INDEX_NOT_FOUND; });
            if (!Array.isArray(ids))
                ids = [ids];
            // get current index
            var destIndex = this.indexes.privateGet(destIndexName);
            // This doesn't work because the array spead sets the object to index: value rather than just the values
            // let test = { ...destIndex };
            // ids.map(k => {
            //   if (test[k]) return;
            //   test[k] = true;
            // });
            // destIndex = Object.keys(test).map(k => Number(k));
            // loop over every id user is trying to add into current index
            for (var i = 0; i < ids.length; i++) {
                // destIndex = destIndex.filter(k => k != ids[i]);
                if (destIndex.includes(ids[i]))
                    continue;
                // push or unshift id into current index
                destIndex[method](ids[i]);
            }
            this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: this.name,
                property: destIndexName,
                value: destIndex
            });
        };
        Collection.prototype.newGroup = function (groupName, indexValue) {
            if (this.indexes.object.hasOwnProperty(groupName))
                return assert(function (warn) { return warn.GROUP_ALREADY_EXISTS; });
            this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: this.name,
                property: groupName,
                value: indexValue
            });
        };
        Collection.prototype.deleteGroup = function (groupName) {
            this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: this.name,
                property: groupName,
                value: []
            });
        };
        Collection.prototype.removeFromGroup = function (groupName, itemsToRemove) {
            if (!this.indexes.exists(groupName))
                return assert(function (warn) { return warn.INDEX_NOT_FOUND; });
            if (!Array.isArray(itemsToRemove))
                itemsToRemove = [itemsToRemove];
            var index = this.indexes.privateGet(groupName);
            var newIndex = index.filter(function (id) { return !itemsToRemove.includes(id); });
            this.global.ingest({
                type: JobType.INDEX_UPDATE,
                collection: this.name,
                property: groupName,
                value: newIndex
            });
        };
        // internal data functions
        Collection.prototype.update = function (primaryKey, newObject) {
            if (!this.internalData.hasOwnProperty(primaryKey))
                return assert(function (warn) { return warn.INTERNAL_DATA_NOT_FOUND; });
            var newObjectKeys = Object.keys(newObject);
            var currentData = Object.assign({}, this.internalData[primaryKey]);
            for (var i = 0; i < newObjectKeys.length; i++) {
                var key_1 = newObjectKeys[i];
                currentData[key_1] = newObject[key_1];
            }
            this.global.ingest({
                type: JobType.INTERNAL_DATA_MUTATION,
                collection: this.name,
                property: primaryKey,
                value: currentData
            });
        };
        Collection.prototype.increment = function (primaryKey, property, amount, decrement) {
            if (!this.internalData.hasOwnProperty(primaryKey))
                return assert(function (warn) { return warn.INTERNAL_DATA_NOT_FOUND; });
            var currentData = Object.assign({}, this.internalData[primaryKey]);
            if (!validateNumber(amount, currentData[property]))
                return assert(function (warn) { return warn.PROPERTY_NOT_A_NUMBER; });
            if (decrement)
                currentData[property] -= amount;
            else
                currentData[property] += amount;
            this.global.ingest({
                type: JobType.INTERNAL_DATA_MUTATION,
                collection: this.name,
                property: primaryKey,
                value: currentData
            });
        };
        Collection.prototype.decrement = function (primaryKey, property, amount) {
            this.increment(primaryKey, property, amount, true);
        };
        Collection.prototype.delete = function (primaryKeys) {
            if (!Array.isArray(primaryKeys))
                primaryKeys = [primaryKeys];
            for (var i = 0; i < primaryKeys.length; i++) {
                var primaryKey = primaryKeys[i];
                this.global.ingest({
                    type: JobType.DELETE_INTERNAL_DATA,
                    collection: this.name,
                    property: primaryKey
                });
            }
        };
        // remove all dynamic indexes, empty all indexes, delete all internal data
        Collection.prototype.purge = function () { };
        // external functions
        Collection.prototype.watch = function (property, callback) {
            if (!this.externalWatchers[property])
                this.externalWatchers[property] = [callback];
            else
                this.externalWatchers[property].push(callback);
        };
        // deprecate
        // added removeFromGroup to be more specific, params got switched around, keeping this for backwards compatibility
        Collection.prototype.remove = function (itemsToRemove, groupName) {
            return this.removeFromGroup(groupName, itemsToRemove);
        };
        return Collection;
    }());
    //# sourceMappingURL=collection.js.map

    // This file handles external components subscribing to pulse.
    var SubController = /** @class */ (function () {
        function SubController(getContext) {
            this.getContext = getContext;
            this.subscribingComponentKey = 0;
            this.subscribingComponent = false;
            this.unsubscribingComponent = false;
            this.skimmingDeepReactive = false;
            this.uuid = uuid;
            this.lastAccessedDep = null;
            this.componentStore = {};
        }
        SubController.prototype.registerComponent = function (instance, config) {
            var uuid = instance.__pulseUniqueIdentifier;
            if (!uuid) {
                // generate UUID
                uuid = this.uuid();
                // inject uuid into component instance
                var componentContainer = {
                    instance: instance,
                    uuid: uuid,
                    ready: config.waitForMount ? false : true
                };
                instance.__pulseUniqueIdentifier = uuid;
                this.componentStore[uuid] = componentContainer;
            }
            else {
                this.mount(instance);
            }
            return uuid;
        };
        SubController.prototype.mount = function (instance) {
            var component = this.componentStore[instance.__pulseUniqueIdentifier];
            if (component) {
                component.instance = instance;
                component.ready = true;
            }
        };
        SubController.prototype.unmount = function (instance) {
            var uuid = instance.__pulseUniqueIdentifier;
            if (!uuid)
                return;
            // delete refrence to this component from store
            delete this.componentStore[instance.__pulseUniqueIdentifier];
        };
        SubController.prototype.subscribePropertiesToComponents = function (properties, componentUUID) {
            // provisionally get keys of mapped data
            var provision = properties(this.getContext());
            var keys = Object.keys(provision);
            // mapData has a user defined local key, we need to include that in the
            // subscription so we know what to update on the component later.
            this.subscribingComponentKey = 0;
            this.subscribingComponent = {
                componentUUID: componentUUID,
                keys: keys
            };
            var returnToComponent = properties(this.getContext());
            this.subscribingComponent = false;
            this.subscribingComponentKey = 0;
            return returnToComponent;
        };
        SubController.prototype.prepareNext = function (dep) {
            this.lastAccessedDep = dep;
            if (!this.skimmingDeepReactive)
                this.subscribingComponentKey++;
        };
        SubController.prototype.foundDeepReactive = function () {
            this.skimmingDeepReactive = true;
            // undo changes
            this.lastAccessedDep.subscribers.pop();
            this.subscribingComponentKey--;
        };
        SubController.prototype.exitDeepReactive = function () {
            this.skimmingDeepReactive = false;
            //redo changes
            this.lastAccessedDep.subscribe();
            this.subscribingComponentKey++;
        };
        return SubController;
    }());
    //# sourceMappingURL=subController.js.map

    var Storage = /** @class */ (function () {
        function Storage(storageMethods) {
            if (storageMethods === void 0) { storageMethods = {}; }
            this.storageMethods = storageMethods;
            this.isPromise = false;
            this.storageReady = false;
            this.storageType = 'localStorage';
            if (storageMethods.async)
                this.isPromise = true;
            // assume if user provided get, set or remove methods that the storage type is custom
            if (storageMethods.get || storageMethods.set || storageMethods.remove) {
                this.storageType = 'custom';
            }
            if (this.localStorageAvaliable() && this.storageType === 'localStorage') {
                this.storageReady = true;
                storageMethods.get = localStorage.getItem.bind(localStorage);
                storageMethods.set = localStorage.setItem.bind(localStorage);
                storageMethods.remove = localStorage.removeItem.bind(localStorage);
            }
            else {
                this.storageType = 'custom';
                if (this.check(storageMethods.get) &&
                    this.check(storageMethods.set) &&
                    this.check(storageMethods.remove)) {
                    this.storageReady = true;
                }
                else {
                    this.storageReady = false;
                    // bad
                }
            }
        }
        Storage.prototype.get = function (collection, key) {
            var _this = this;
            if (!this.storageReady)
                return;
            if (this.isPromise) {
                return new Promise(function (resolve, reject) {
                    _this.storageMethods
                        .get(_this.getKey(collection, key))
                        .then(function (res) {
                        // if result is not JSON for some reason, return it.
                        if (typeof res !== 'string')
                            return resolve(res);
                        resolve(JSON.parse(res));
                    })
                        .catch(reject);
                });
            }
            else {
                return JSON.parse(this.storageMethods.get(this.getKey(collection, key)));
            }
        };
        Storage.prototype.set = function (collection, key, value) {
            if (!this.storageReady)
                return;
            this.storageMethods.set(this.getKey(collection, key), JSON.stringify(value));
        };
        Storage.prototype.remove = function (collection, key) {
            if (!this.storageReady)
                return;
            this.storageMethods.remove(this.getKey(collection, key));
        };
        Storage.prototype.getKey = function (collection, key) {
            return "_" + collection + "_" + key;
        };
        Storage.prototype.check = function (func) {
            return typeof func === 'function';
        };
        Storage.prototype.localStorageAvaliable = function () {
            try {
                localStorage.setItem('_', '_');
                localStorage.removeItem('_');
                return true;
            }
            catch (e) {
                return false;
            }
        };
        return Storage;
    }());
    //# sourceMappingURL=storage.js.map

    var Request = /** @class */ (function (_super) {
        __extends(Request, _super);
        function Request(global, requestConfig) {
            var _this = this;
            // Before we invoke the parent class, we define some defaults
            var groups = [];
            var persist = ['baseURL'];
            var data = {
                baseURL: requestConfig.baseURL || '',
                mode: 'cors',
                credentials: 'same-origin',
                headers: {
                    Accept: 'application/json'
                }
            };
            if (requestConfig.headers)
                Object.keys(requestConfig.headers).forEach(function (header) {
                    data.headers[header] = requestConfig.headers[header];
                });
            if (requestConfig.credentials)
                data.credentials = requestConfig.credentials;
            if (requestConfig.mode)
                data.mode = requestConfig.mode;
            _this = _super.call(this, 'request', global, { groups: groups, data: data, persist: persist }) || this;
            _this.requestIntercept = requestConfig.requestIntercept;
            _this.responseIntercept = requestConfig.responseIntercept;
            _this.timeout = requestConfig.timeout;
            _this.saveHistory =
                typeof requestConfig.saveHistory === 'undefined' ? true : false;
            _this.global.request = {
                get: _this.get.bind(_this),
                post: _this.post.bind(_this),
                put: _this._put.bind(_this),
                patch: _this.patch.bind(_this),
                delete: _this.delete.bind(_this),
                queryify: _this.queryify.bind(_this)
            };
            return _this;
        }
        Request.prototype.get = function (url, headers) {
            return this.send(url, 'get', {}, headers);
        };
        Request.prototype.post = function (url, body, headers) {
            return this.send(url, 'post', body, headers);
        };
        Request.prototype._put = function (url, body, headers) {
            return this.send(url, 'put', body, headers);
        };
        Request.prototype.patch = function (url, body, headers) {
            return this.send(url, 'patch', body, headers);
        };
        Request.prototype.delete = function (url, body, headers) {
            return this.send(url, 'delete', body, headers);
        };
        Request.prototype.send = function (url, method, body, headers) {
            if (body === void 0) { body = {}; }
            return __awaiter(this, void 0, void 0, function () {
                var requestHeaders, fullURL, options, response, contentType, final, keys, i, property;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            requestHeaders = Object.assign({}, this.public.object.headers);
                            if (headers)
                                Object.keys(headers).forEach(function (header) {
                                    requestHeaders[header] = headers[header];
                                });
                            // If method is not get set application type
                            if (method !== 'get' && requestHeaders['Content-Type'] === undefined)
                                requestHeaders['Content-Type'] = 'application/json';
                            if (url.startsWith('http'))
                                fullURL = url;
                            else
                                fullURL = this.public.object.baseURL + "/" + url;
                            // Stringify body
                            body = JSON.stringify(body);
                            // Build options
                            this.options = {};
                            this.options.credentials = this.public.object.credentials;
                            this.options.mode = this.public.object.mode;
                            options = Object.assign({
                                headers: requestHeaders,
                                method: method.toUpperCase(),
                                body: method === 'get' ? null : body
                            }, this.options);
                            if (this.requestIntercept)
                                this.requestIntercept(this.global.getContext('request'), options);
                            if (!this.timeout) return [3 /*break*/, 2];
                            return [4 /*yield*/, Promise.race([
                                    fetch(fullURL, options),
                                    new Promise(function (resolve, reject) {
                                        return setTimeout(function () { return reject('timeout'); }, _this.timeout);
                                    })
                                ])];
                        case 1:
                            response = _a.sent();
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, fetch(fullURL, options)];
                        case 3:
                            response = _a.sent();
                            _a.label = 4;
                        case 4:
                            contentType = response.headers.get('content-type');
                            if (!(contentType && contentType.indexOf('application/json') !== -1)) return [3 /*break*/, 6];
                            return [4 /*yield*/, response.json()];
                        case 5:
                            body = _a.sent();
                            return [3 /*break*/, 8];
                        case 6: return [4 /*yield*/, response.text()];
                        case 7:
                            body = _a.sent();
                            _a.label = 8;
                        case 8:
                            // history
                            if (!this.saveHistory)
                                this.collect({
                                    id: Date.now(),
                                    status: response.status,
                                    timestamp: new Date(),
                                    response: body
                                });
                            // If reponse body is an object, create a custom object with response function in prototype, so headers and the full response data can be accessed outside of this class
                            if (!Array.isArray(body) && typeof body === 'object') {
                                final = Object.create({
                                    response: function () {
                                        return response;
                                    }
                                });
                                keys = Object.keys(body);
                                for (i = 0; i < keys.length; i++) {
                                    property = keys[i];
                                    final[property] = body[property];
                                }
                                // if the body is not an object, we can not inject a prototype, so just return the rew body
                            }
                            else {
                                final = body;
                            }
                            // intercept response
                            if (this.responseIntercept) {
                                response.data = body;
                                this.responseIntercept(this.global.getContext('request'), response);
                            }
                            // reject if bad response status
                            if (response.ok || response.redirected)
                                return [2 /*return*/, final];
                            // resolve response
                            throw final;
                    }
                });
            });
        };
        // Adapted from: https://github.com/Gozala/querystring/blob/master/encode.js
        Request.prototype.queryify = function (obj) {
            var stringifyPrimitive = function (value) {
                switch (typeof value) {
                    case 'string':
                        return value;
                    case 'boolean':
                        return value ? 'true' : 'false';
                    case 'number':
                        return isFinite(value) ? value : '';
                    default:
                        return '';
                }
            };
            // validate input
            if (typeof obj != 'object')
                return;
            return Object.keys(obj)
                .map(function (key) {
                var encodedKey = encodeURIComponent(stringifyPrimitive(key)) + '=';
                // if value is an array, encode with same key as parent
                if (Array.isArray(obj[key]))
                    return obj[key]
                        .map(function (value) {
                        return encodedKey + encodeURIComponent(stringifyPrimitive(value));
                    })
                        .join('&');
                // join encoded key with value
                return encodedKey + encodeURIComponent(stringifyPrimitive(obj[key]));
            })
                .join('&');
        };
        return Request;
    }(Collection));
    //# sourceMappingURL=request.js.map

    var Request$1 = /** @class */ (function (_super) {
        __extends(Request, _super);
        function Request(global, root) {
            if (root === void 0) { root = {}; }
            var _this = this;
            root = Object.assign({}, root);
            // Base as a collection is configured directly from the root of the Pulse config,
            // thus to be verbose we remove the properties only used for global setup
            // default collection properties like data, computed, actions etc will remain
            delete root.collections;
            delete root.request;
            // if user has not created data or persist properties, create them for the defaults.
            if (!root.data)
                root.data = {};
            if (!root.persist)
                root.persist = [];
            // can be used to preserve authenticated state
            // automatically persists if local storage is availible
            root.data['isAuthenticated'] = false;
            root.persist.push('isAuthenticated');
            // can be used to declare once the app has finished initilazation, does not affect Pulse
            root.data['appReady'] = false;
            _this = _super.call(this, 'base', global, root) || this;
            return _this;
        }
        return Request;
    }(Collection));
    //# sourceMappingURL=base.js.map

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    var defineProperty = _defineProperty;

    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);

        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }

        ownKeys.forEach(function (key) {
          defineProperty(target, key, source[key]);
        });
      }

      return target;
    }

    var objectSpread = _objectSpread;

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    var classCallCheck = _classCallCheck;

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    var createClass = _createClass;

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var _typeof_1 = createCommonjsModule(function (module) {
    function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

    function _typeof(obj) {
      if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
        module.exports = _typeof = function _typeof(obj) {
          return _typeof2(obj);
        };
      } else {
        module.exports = _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
        };
      }

      return _typeof(obj);
    }

    module.exports = _typeof;
    });

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    var assertThisInitialized = _assertThisInitialized;

    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof_1(call) === "object" || typeof call === "function")) {
        return call;
      }

      return assertThisInitialized(self);
    }

    var possibleConstructorReturn = _possibleConstructorReturn;

    var getPrototypeOf = createCommonjsModule(function (module) {
    function _getPrototypeOf(o) {
      module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    module.exports = _getPrototypeOf;
    });

    var setPrototypeOf = createCommonjsModule(function (module) {
    function _setPrototypeOf(o, p) {
      module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    module.exports = _setPrototypeOf;
    });

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) setPrototypeOf(subClass, superClass);
    }

    var inherits = _inherits;

    function _extends() {
      _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      return _extends.apply(this, arguments);
    }

    function withPulse(pulse, React, ReactComponent, selectData) {
      return (
        /*#__PURE__*/
        function (_React$Component) {
          inherits(_class, _React$Component);

          function _class(props) {
            var _this;

            classCallCheck(this, _class);

            _this = possibleConstructorReturn(this, getPrototypeOf(_class).call(this, props));
            _this.state = objectSpread({}, pulse.mapData(selectData, assertThisInitialized(_this), {
              waitForMount: pulse._private.global.config.waitForMount === false ? false : true
            }, pulse));
            return _this;
          }

          createClass(_class, [{
            key: "componentDidMount",
            value: function componentDidMount() {
              if (pulse._private.global.config.waitForMount) pulse.mount(this);
            }
          }, {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
              if (pulse._private.global.config.autoUnmount) pulse.unmount(this);
            }
          }, {
            key: "render",
            value: function render() {
              return React.createElement(ReactComponent, _extends({
                pulse: this.state
              }, this.props));
            }
          }]);

          return _class;
        }(React.Component)
      );
    }

    var Library = /** @class */ (function () {
        function Library(root) {
            var _this = this;
            if (root === void 0) { root = {}; }
            // Private object contains all internal Pulse data
            this._private = {
                runtime: null,
                events: {},
                collections: {},
                collectionKeys: [],
                // global is passed in to all classes, must not contain cyclic references
                global: {
                    config: this.prepareConfig(root.config),
                    // State
                    initComplete: false,
                    runningAction: false,
                    runningWatcher: false,
                    runningComputed: false,
                    runningPopulate: false,
                    mappingData: false,
                    collecting: false,
                    touching: false,
                    touched: false,
                    contextRef: {},
                    // Instances
                    subs: new SubController(this.getContext.bind(this)),
                    relations: null,
                    storage: null,
                    // Function aliases
                    ticket: this.ticket.bind(this),
                    cleanupTickets: this.cleanupTickets.bind(this),
                    dispatch: this.dispatch.bind(this),
                    getInternalData: this.getInternalData.bind(this),
                    getContext: this.getContext.bind(this),
                    getDep: this.getDep.bind(this),
                    uuid: uuid
                }
            };
            // Bind static objects to instance (utils and services eventually should be initialized)
            ['utils', 'services', 'staticData'].forEach(function (type) {
                if (root[type])
                    _this[type] = root[type];
            });
            // Create storage instance
            this._private.global.storage = new Storage(root.storage);
            // Create relation controller instance
            this._private.global.relations = new RelationController(this._private.global);
            // Prepare
            this.initCollections(root);
            this.initRuntime();
            // Finalize
            this.bindCollectionPublicData();
            this.runAllComputed();
            this.initComplete();
        }
        Library.prototype.initCollections = function (root) {
            this._private.collectionKeys = [];
            if (root.collections) {
                this._private.collectionKeys = Object.keys(root.collections).concat(this._private.collectionKeys);
                for (var i = 0; i < this._private.collectionKeys.length; i++) {
                    // Create collection instance
                    this._private.collections[this._private.collectionKeys[i]] = new Collection(this._private.collectionKeys[i], // name
                    this._private.global, // global
                    root.collections[this._private.collectionKeys[i]] // collection config
                    );
                }
            }
            // Create request class
            if (this._private.global.config.enableRequest !== false)
                this._private.collectionKeys.push('request');
            this._private.collections['request'] = new Request(this._private.global, root.request || {});
            // Create base class
            if (this._private.global.config.enableBase !== false) {
                this._private.collectionKeys.push('base');
                this._private.collections['base'] = new Request$1(this._private.global, root);
            }
        };
        Library.prototype.initRuntime = function () {
            this._private.runtime = new Runtime(this._private.collections, this._private.global);
        };
        Library.prototype.bindCollectionPublicData = function () {
            for (var i = 0; i < this._private.collectionKeys.length; i++) {
                var collection = this._private.collections[this._private.collectionKeys[i]];
                this._private.global.contextRef[this._private.collectionKeys[i]] =
                    collection.public.object;
                this[this._private.collectionKeys[i]] = collection.public.object;
            }
        };
        Library.prototype.runAllComputed = function () {
            for (var i = 0; i < this._private.collectionKeys.length; i++) {
                var collection = this._private.collections[this._private.collectionKeys[i]];
                var computedKeys = collection.keys.computed;
                for (var i_1 = 0; i_1 < computedKeys.length; i_1++) {
                    var computedName = computedKeys[i_1];
                    this._private.runtime.performComputedOutput({
                        collection: collection.name,
                        property: computedName,
                        type: JobType.COMPUTED_REGEN
                    });
                    collection.runWatchers(computedName);
                }
            }
        };
        Library.prototype.initComplete = function () {
            this._private.global.initComplete = true;
            log('INIT COMPLETE', Object.assign({}, this));
            if (!this._private.global.config.ssr) {
                try {
                    window._pulse = this;
                }
                catch (e) { }
            }
        };
        Library.prototype.wrapped = function (ReactComponent, mapData) {
            var config = this._private.global.config;
            if (config.framework === 'react' && config.frameworkConstructor) {
                return withPulse(this, config.frameworkConstructor, ReactComponent, mapData);
            }
            else
                return false;
        };
        Library.prototype.prepareConfig = function (config) {
            // defaults
            config = defineConfig(config, {
                framework: null,
                waitForMount: false,
                autoUnmount: false
            });
            // detect if framework passed in is a React constructor
            if (config.framework &&
                config.framework.hasOwnProperty('__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED')) {
                config.frameworkConstructor = config.framework;
                config.framework = 'react';
            }
            if (config.framework === 'react') {
                if (config.waitForMount != false)
                    config.waitForMount = true;
                if (config.autoUnmount != false)
                    config.autoUnmount = true;
            }
            return config;
        };
        Library.prototype.getInternalData = function (collection, primaryKey) {
            return this._private.collections[collection].findById(primaryKey);
        };
        // returns Dep instance by "touching" reactive property revealing its Dep class
        // if collection param is present we'll assume the property param is the name of the property, not a reference to the property itself
        Library.prototype.getDep = function (property, collection) {
            this._private.global.touching = true;
            // "touching" is simply invoking the property's getter
            if (typeof collection === 'string') {
                this._private.collections[collection].public.object[property];
            }
            else if (typeof collection === 'object') {
                collection[property];
            }
            // Extract the dep
            var dep = this._private.global.touched;
            this._private.global.touching = false;
            this._private.global.touched = null;
            return dep;
        };
        Library.prototype.dispatch = function (type, payload) {
            switch (type) {
                case 'mutation':
                    this._private.runtime.ingest({
                        type: JobType.PUBLIC_DATA_MUTATION,
                        collection: payload.collection,
                        property: payload.key,
                        value: payload.value,
                        dep: payload.dep
                    });
                    break;
                default:
                    break;
            }
        };
        Library.prototype.getContext = function (collection) {
            var c = this._private.collections[collection];
            if (!c)
                return this._private.global.contextRef;
            return __assign({}, this._private.global.contextRef, c.methods, { data: c.public.object, indexes: c.indexes.object, groups: c.public.object, computed: c.public.object, routes: c.public.object.routes, local: c.local });
        };
        Library.prototype.install = function (Vue) {
            this._private.global.config.framework = 'vue';
            var pulse = this;
            var config = pulse._private.global.config;
            Vue.mixin({
                beforeCreate: function () {
                    var _this = this;
                    Object.keys(pulse._private.global.contextRef).forEach(function (collection) {
                        _this['$' + collection] = pulse._private.global.contextRef[collection];
                    });
                    if (pulse.utils)
                        this.$utils = pulse.utils;
                    if (pulse.services)
                        this.$services = pulse.services;
                    if (pulse.staticData)
                        this.$staticData = pulse.staticData;
                    this.mapData = function (properties) {
                        return pulse.mapData(properties, _this, {
                            waitForMount: config.waitForMount
                        }, pulse);
                    };
                },
                mounted: function () {
                    if (this.__pulseUniqueIdentifier && config.waitForMount)
                        pulse.mount(this);
                },
                beforeDestroy: function () {
                    if (this.__pulseUniqueIdentifier && config.autoUnmount)
                        pulse.unmount(this);
                }
            });
        };
        Library.prototype.mount = function (instance) {
            this._private.global.subs.mount(instance);
        };
        Library.prototype.unmount = function (instance) {
            this._private.global.subs.unmount(instance);
        };
        Library.prototype.mapData = function (properties, instance, _config, pulseAlias) {
            if (instance === void 0) { instance = {}; }
            if (_config === void 0) { _config = {}; }
            var pulse = pulseAlias ? pulseAlias : this;
            var config = __assign({ waitForMount: true }, _config);
            var componentUUID = pulse._private.global.subs.registerComponent(instance, config);
            this._private.global.mappingData = true;
            // new cool mapData method
            if (typeof properties === 'function') {
                return pulse._private.global.subs.subscribePropertiesToComponents(properties, componentUUID);
                // legacy support....
            }
            else if (typeof properties === 'object') {
                var returnData_1 = {};
                normalizeMap(properties).forEach(function (_a) {
                    var key = _a.key, val = _a.val;
                    var collection = val.split('/')[0];
                    var property = val.split('/')[1];
                    var c = pulse._private.global.getContext()[collection];
                    returnData_1[key] = pulse._private.global.subs.subscribePropertiesToComponents(function () {
                        var _a;
                        return _a = {}, _a[key] = c[property], _a;
                    }, componentUUID)[key];
                });
                this._private.global.mappingData = false;
                return returnData_1;
            }
        };
        Library.prototype.emit = function (name, payload) {
            if (this._private.events[name])
                for (var i = 0; i < this._private.events[name].length; i++) {
                    var callback = this._private.events[name][i];
                    callback(payload);
                }
        };
        Library.prototype.on = function (name, callback) {
            if (!Array.isArray(this._private.events[name]))
                this._private.events[name] = [callback];
            else
                this._private.events[name].push(callback);
        };
        // root alias for relationController to access ticket function of a given collection
        Library.prototype.ticket = function (collection, uuid, key) {
            var primaryKey = parse(key).primaryKey;
            this._private.collections[collection].ticket(uuid, primaryKey);
        };
        // root alias for relationController to access cleanupTicket function of a given collection
        Library.prototype.cleanupTickets = function (key) {
            var parsed = parse(key);
            this._private.collections[parsed.collection].cleanupTickets(parsed.primaryKey);
        };
        Library.prototype.log = function (type) {
            // let debugMode: Set<DebugType> = this._private.global.config.debugMode;
            // if (debugMode.size === 0) return;
            // if (debugMode.has(DebugType.ERRORS)) {
            // }
            // log(DebugType.ASSERT, `There was an error with "${thing}", bad :(`);
            // const AssertMessages = {
            //   INDEX_UPDATE_FAILED: (collection, property) =>
            //     `The type ${collection} is ${property}.`
            //   // and more
            // };
            // function _log(callback) {
            // }
            // _log(({ AssertMessages }) => AssertMessages.INDEX_UPDATE_FAILED(thing, thing2));
        };
        return Library;
    }());

    //# sourceMappingURL=index.js.map

    return Library;

}));
//# sourceMappingURL=pulse.min.js.map
